{"meta":{"title":"YanYi Blog","subtitle":"妍一","description":"妍一的个人博客","author":"YanYi","url":"https://yanyi1991.github.io","root":"/"},"pages":[{"title":"","date":"2024-04-10T12:38:26.076Z","updated":"2024-04-10T12:38:26.076Z","comments":true,"path":"404.html","permalink":"https://yanyi1991.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2024-04-10T12:35:52.000Z","updated":"2024-04-12T01:05:30.396Z","comments":true,"path":"categories/index.html","permalink":"https://yanyi1991.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2024-04-10T12:35:01.000Z","updated":"2024-04-12T01:19:05.407Z","comments":true,"path":"about/index.html","permalink":"https://yanyi1991.github.io/about/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-04-10T12:36:26.000Z","updated":"2024-04-12T01:04:46.542Z","comments":true,"path":"tags/index.html","permalink":"https://yanyi1991.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2024-04-10T12:36:51.000Z","updated":"2024-04-12T01:03:29.458Z","comments":true,"path":"friends/index.html","permalink":"https://yanyi1991.github.io/friends/index.html","excerpt":"有什么想说的🐎？","text":"有什么想说的🐎？ 没有什么可说的呢，暂时没有去写这个页面。"}],"posts":[{"title":"stm32_Day1","slug":"stm32-Day1","date":"2024-04-14T10:33:08.000Z","updated":"2024-04-16T01:39:51.701Z","comments":true,"path":"2024/04/14/stm32-Day1/","link":"","permalink":"https://yanyi1991.github.io/2024/04/14/stm32-Day1/","excerpt":"","text":"1.STM32 Nucleo开发板简介1.官方开发板1.Nucleo Borad（灵活搭建产品原型，使用最为广泛） 2.Discovery Kit（针对芯片的重要性能进行参考评估） 3.Evaluation Board（功能最为强大，可以对芯片的全部功能进行参考评估） 2.Nucleo开发板电路特点1.模块化的设计（ST-Link仿真器+MCU核心板） 2.统一的MCU核心板设计（一板多用） 3.丰富的接口拓展（Arduino生态） 4.简洁的外设模块（指示灯和按键） 5.多功能的USB接口（虚拟串口，大容量存储，调试接口） 6.灵活的供电方式（USB供电，外部供电） 7.支出多种开发环境（MDK-ARM，EWARM，Mbed） 最大的优势就是提供了ARDUINO的扩展接口 3.按照引脚数量来分类(系列)1.Nucleo32 2.Nucleo64 3.Nucleo144 上半部分（ST-Link仿真器） 下半部分（MCU核心板） 4.电路模块CN4：SWD调试接口 B1：用户按键 LD3：电源指示灯 主控芯片：STM32F411RET CN7：外扩引脚接口（便于用户二次开发） CN1：USB接口 B2：复位按键 LD2：用户指示灯 CN5&#x2F;6&#x2F;8&#x2F;9：Arduino接口 CN10：外扩引脚接口（便于用户二次开发） 5.STM32F411RET6 片内资源存储器方面：512KB Flash 和 128KB SRAM 定时器方面：1个16位高级定时器，2个32位通用定时器，5个16位通用定时器 连接接口方面：3路USART（串口），5路SPI&#x2F;I2S，3路I2C，1路SDIO AD采集方面：1路12位16通道ADC USB接口方面：1个全速USB 2.0 OTG 数字IO数量方面：50个通用数字I&#x2F;O口 6.主控芯片的引脚(5大类)1.电源引脚VDD&#x2F;VSS：为片内集成的数字外设供电（8个） VDDA&#x2F;VSSA：为片内集成的模拟外设供电（2个） VBAT：为片内的实时时钟供电，确保断电后能正常工作（1个） VCAP_1：用于电源滤波（1个） 2.复位及启动模式引脚NRST（复位引脚）：复位电平为低电平有效（1个） BOOT0，PB2（BOOT1）：启动引脚，两个引脚决定芯片的启动模式（2个） 3.时钟引脚OSC32_IN,OSC32_OUT：接入外部低速时钟（2个） OSC_IN,OSC_OUT：接入外部高速时钟（2个） 4.仿真调试引脚PA13,PA14：作为SWD的穿行调试接口（2个） 5.通用数字I&#x2F;O引脚]除了作为数字I&#x2F;O意外，还作为片内外设的功能引脚 2.Nucleo开发版最小系统设计微控制器最小系统的定义： 狭义：仅包括电源电路，时钟电路，复位电路，调试电路及主控芯片电路 广义：还包括基本的人机接口电路，如指示灯，按键，蜂鸣器，数码管及串口通信等电路 以狭义为例： 1.电源电路：为整个电路系统提供所需的供电电压两种供电方式：外部和USB VIN：外部供电端口（可以输入7V到12V的直流电压），经过电压转换芯片（LD1117S50TR）转换出5V的电源电压 E5V：外部供电端口（可以输入5V的直流电压） +3V3：外部供电端口（可以输入3.3V的直流电压） 注：三个外部电源输入均引出到外扩接口 U5V：USB供电（可以输入5V的直流电压） 最后通过JP5进行电源输入的选择，当2-3短接（外部供电），当2-1短接（USB供电），默认USB供电 LD3用于指示电路板已经正常上电，再通过电压转换芯片（LD39050PU33R）转换出3.3V的供电电压（VDD），最后提供给目标MCU及外围电路 2.时钟电路：为MCU提供所需的时钟信号时钟源： LSI：内部低速时钟，由片内RC振荡器提供，默认频率32KHz HSI：内部高速时钟，由片内RC振荡器提供，默认频率16MHz HSE：外部高速时钟，通过OSC_IN和OSC_OUT引脚接入晶振实现，频率范围（4MHz-26MHz）,也可以直接接入外部时钟信号，频率范围（1MHz-50MHz） LSE：外部低速时钟，通过OSC32_IN和OSC32_OUT引脚接入32.768KHz的晶振实现 时钟电路的两种设计方法：震荡模式&#x2F;旁路模式（一般使用震荡模式） 外部高速时钟HSE：通过晶振X3和两个匹配电容C33和C34（阻值为20p）接入到OSC_IN和OSC_OUT引脚（默认没有焊接晶振X3），实际使用的时钟来自于ST-Link仿真器所提供的8MHz时钟，因此实际上Nucleo开发板上时钟电路选择的是旁路模式 外部低速时钟LSE：通过晶振X2和两个匹配电容C31和C32（阻值为4.3p）接入到OSC32_IN和OSC32_OUT引脚。 要想使用震荡模式（添加外部晶振）： 1.断开焊桥SB16，SB50，SB54和SB55 2.焊接8MHz石英晶体X3 3.焊接2个20pF电容C33和C34 4.焊接2个0欧电阻R35和R37或者用焊锡短接 3.调试电路：位MCU提供程序下载和调试的接口两种调试接口（JTAG调试接口&#x2F;SWD调试接口） 4.复位电路：为MCU提供统一的初始状态采用了传统的阻容复位电路（上电复位和手动复位）由MCU的复位引脚NRST内部的上拉电阻和电容C14g构成，阻容复位提供上电复位的功能，复位按键B2提供手动复位的功能，当B2按下（NRST与地连接）用于系统复位，在工程实际中，一般使用专用复位芯片（SP706S）来构成复位电路，可以提供标准的复位脉冲，还提供了电压监控 5.主控芯片 BOOT0 BOOT1 启动模式 说明 0 X 用户闪存存储器 从MCU片内Flash启动，常用启动方式 1 0 系统存储器 从系统存储器启动，主要用于串口下载（ISP模式） 1 1 SRAM启动 从MCU片内SRAM启动，主要用于代码调试 （0，X）用户闪存存储器是最常用的启动模式","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://yanyi1991.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://yanyi1991.github.io/tags/STM32/"}]},{"title":"Java开发命令行程序","slug":"Java开发命令行程序","date":"2024-04-10T14:42:09.000Z","updated":"2024-04-16T03:31:10.631Z","comments":true,"path":"2024/04/10/Java开发命令行程序/","link":"","permalink":"https://yanyi1991.github.io/2024/04/10/Java%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"一. 输入输出 输入的作用，就是由使用者告诉程序要操作的数据 例如，我要通过饿了么订餐，你得告诉程序你要吃什么，送货地址是什么吧 输出的作用，就是由程序向使用者展现执行的结果 还是订餐的例子，程序向你展示骑手接单没有，送到哪里了 将来输入输出来源会有多种，比如 app，网页，终端程序等等 1. System.out之前已经介绍过【标准输出】：System.out 打开 jshell 用一下，回忆下对象和方法使用格式 对象.方法(参数); 套用一下，对象是 System.out，方法是 println，参数是 “你好” jshell&gt; System.out.println(“你好”); 你好 小技巧 jshell 中用 Tab 键可以提示对象有哪些方法 jshell 中省略 ; 也不会报错 2. System.in再来看看输入，对象是 System.in，方法叫 read，没有参数 jshell&gt; System.in.read(); 运行后，可以看到光标一闪一闪，表示正在等待用户的输入，这时输入小 a jshell&gt; System.in.read(); a $1 &#x3D;&#x3D;&gt; 97 会显示 97，称之为返回值，代表 read() 读入的结果 因为计算机中所有符号，都是用数字表示，参看下表 前面的 $1 是一个【变量】，将来它就代表 97，也就是刚才输入的小 a 【变量】可以反复被使用 \\ 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 0000 无 无 无 无 无 无 无 无 无 无 无 无 无 无 无 无 0016 无 无 无 无 无 无 无 无 无 无 无 无 无 无 无 无 0032 ! “ # $ % &amp; ‘ ( ) * + , - . &#x2F; 0048 0 1 2 3 4 5 6 7 8 9 : ; &lt; &#x3D; &gt; ? 0064 @ A B C D E F G H I J K L M N O 0080 P Q R S T U V W X Y Z [ \\ ] ^ _ 0096 &#96; a b c d e f g h i j k l m n o 0112 p q r s t u v w x y z { \\ } ~ System.in 的缺点 字符被转成的数字，不便人类阅读 只能输入一个字符 3. Scanner用 Scanner 改进，System.in 是 java 为我们提供好的对象，而 Scanner 需要我们自己创建，语法是 jshell&gt; new Scanner(System.in); $2 &#x3D;&#x3D;&gt; java.util.Scanner… 将来这个 $2 就代表刚才的 Scanner 对象，我们称之为【变量】 Scanner 对象里面最常用的方法是 nextLine，用法如下 jshell&gt; $2.nextLine(); 你好啊 $3 &#x3D;&#x3D;&gt; “你好啊” 4. 变量名$2，$3 这样作为变量名虽然也可以，但如果用更有意义的名称来表示，更方便人类阅读、记忆。例如 jshell&gt; var scanner &#x3D; new Scanner(System.in) scanner &#x3D;&#x3D;&gt; java.util.Scanner[delimiters&#x3D;\\p{javaWhitespace}+] … \\E][infinity string&#x3D;\\Q∞\\E] jshell&gt; var line &#x3D; scanner.nextLine() hello line &#x3D;&#x3D;&gt; “hello” scanner 就代指输入对象 line 就代指用 nextLine() 读取到的字符串值 var 是关键字，代表某种类型，具体有哪些类型后面再展开 5. 关键字变量取名时要注意两个规则，不能以数字开头，不能是关键字 什么是关键字呢？关键字就是 java 中有特殊意义的单词，例如见过的有 class，var，new 等等，如果用 idea 中可以通过特殊颜色强调哪些单词是关键字，可以看到这些蓝色的单词都属于关键字 至java 17 为止，共有 67 个关键字，参看这两份表格，这些关键字，都会在今后的课程中陆续学到   二. 类型、变量、运算符1. 字符与字符串字符值与字符串值像这样用双引号引起来的值，在 Java 里称为字符串，字符串顾名思义，由多个字符组成，单个字符用单引号表示，例如 jshell&gt; ‘a’ $4 &#x3D;&#x3D;&gt; ‘a’ jshell&gt; “abc” $5 &#x3D;&#x3D;&gt; “abc” 单引号里必须由一个字符 双引号里可以有零个、一个、多个字符 转义字符比如我需要输出一个单引号字符值，&#39;&#39;&#39; 这样写行不行？本意是想表示中间的单引号，但遗憾的是java把前两个单引号当成了一对，把它当作了那个空字符了 怎么办呢 为了把真正的单引号跟语法的单引号区分开，需要给它加一个反斜杠标记，告诉java，我想表示真正的单引号，而不是语法中的单引号。试一下。 jshell&gt; System.out.println(“&#39;“) ‘ 这种结合了反斜杠的具有特殊含义的字符，称之为转义字符（Escape Character） 常见的有七个：\\&#39; \\&quot; \\\\ \\n \\t \\b \\r 刚才已经讲过单引号转义了 继续来看几个例子 jshell&gt; System.out.println(“&quot;“) &#x2F;&#x2F; 双引号转义 “ jshell&gt; System.out.println(“\\“) &#x2F;&#x2F; 反斜杠本身转义 jshell&gt; System.out.println(“1\\n2”) &#x2F;&#x2F; 换行 1 2 jshell&gt; System.out.println(&quot;123\\t4&quot;) // 缩进 123 4 jshell&gt; System.out.println(&quot;123\\b4&quot;) // 退格 124 jshell&gt; System.out.println(&quot;123\\r4&quot;) // 回车，退格是光标退一格，回车是退到头 423 文本块最后再再来看看文本块，如果有一段文字内，其中需要有很多的转义字符，那么可读性会变得很差，例如 jshell&gt; System.out.println(“床前&quot;明月&quot;光，\\n疑是地上霜。”) 因此在 java 14 这个版本引入了文本块来进行改善。 jshell&gt; System.out.println(“”” 床前”明月”光， 疑是地上霜。”””) 文本块本质上还是属于字符串值，由一对 三个双引号作为起始和结束标记，中间如果想表示双引号、换行这两个特殊字符，无需再转义表示 一个注意事项是 “”” 后需要换个行，不要紧接着写字符。 2. 类型何为类型现在让用户输入两个数，求得相加结果 jshell&gt; scanner.nextLine() 1 $22 &#x3D;&#x3D;&gt; “1” jshell&gt; scanner.nextLine() 2 $23 &#x3D;&#x3D;&gt; “2” jshell&gt; $22 + $23 $24 &#x3D;&#x3D;&gt; “12” 显然，这并不是我们想要的结果，它是输入的值当作了字符串，+ 号执行的是字符串连接操作，解决办法如下 jshell&gt; scanner.nextInt() 1 $25 &#x3D;&#x3D;&gt; 1 jshell&gt; scanner.nextInt() 2 $26 &#x3D;&#x3D;&gt; 2 jshell&gt; $25 + $26 $27 &#x3D;&#x3D;&gt; 3 nextLine() 和 nextInt() 返回的类型是不同的 前者返回的是字符串，类型为 String，+ 表示两个字符串连接 后者返回的是整数，类型为 int，+ 表示两个整数相加 数字类型 类型名 说明 数字范围 类型后缀 byte 整数类型，用1个字节表示 $[-2^7,2^7)$ 即 $[-128,128)$ short 整数类型，用2个字节表示 $[-2^{15},2^{15})$ int 整数类型，用4个字节表示 $[-2^{31},2^{31})$ long 整数类型，用8个字节表示 $[-2^{63},2^{63})$ L float 浮点小数，用4个字节表示 $[-1.9999999 * 2^{127},1.9999999 * 2^{127}]$ F double 浮点小数，用8个字节表示 $[-1.9999999 * 2^{1023},1.9999999 * 2^{1023}]$ D [] 包含等于，() 不包含等于 类型后缀 不区分大小写，但建议用大写，因为小写的 L 与 1 容易混淆 尾符号 D 可以省略 float 和 double 精度不同，即小数点后的位数 float 的精度二进制是 23，换算成十进制是 6~7 double 的精度二进制是 52，换算成十进制是 15~16 字符类型 类型名 说明 范围 char 字符类型，配合单引号 $[0,2^{16})$ 即 $[0, 65536)$ String 字符串类型，配合双引号或文本块 - 3. 变量与运算符变量变量的定义格式为 类型 变量名 &#x3D; 值; 从语法可以看到，变量由类型和名称组成，类型决定了变量能存储的数据大小与数据格式，名字用来代表后面的值 这个语法其实咱们前面见过类似的，var scanner &#x3D; new Scanner(System.in)，这里 var 是类型，因为之前我们还没有学习具体有哪些类型，因此使用了 var 来代表某种类型，scanner是变量名，后面这一串就是值，也是 Scanner 对象 &#x3D; 称之为赋值运算符，可以用来更新变量代表的值。 例如： int a &#x3D; 10 这行代码的意思是，定义了整型变量a，更新它的初始值为10 再来一句： a &#x3D; 20 这时候为啥不用写前面的类型了呢，因为变量定义只需一次，定义好之后变量就可以反复使用了，这行代码的意思是，将 a 所代表的值更新为 20 变量可以用来保存运算的结果，它自身也能参与运算 运算符int a = 5 + 3 结果为 8 int a &#x3D; 5 - 3 结果为 2 int a &#x3D; 5 * 3 结果为 15 int a &#x3D; 5 &#x2F; 3 结果为 1，整数除法有两个注意点 整数除法，只会保留商，而小数部分会被舍弃，并不考虑四舍五入 除0是不合法的，会出错 int a &#x3D; 5 % 3 结果为 2 小数加减乘除与整数类似，只是小数除法可以保留小数点后的数字，而且可以除零，例如 jshell&gt; 5.0 &#x2F; 3.0 $40 &#x3D;&#x3D;&gt; 1.6666666666666667 jshell&gt; 5.0 &#x2F; 0.0 $41 &#x3D;&#x3D;&gt; Infinity 增强赋值运算符 int a &#x3D; 20; a &#x3D; a + 10; 意思是，获取 a 的原有值 20，执行加 10 运算，将新的结果重新赋值给 a，a 代表的值被更新成了 30。可以用 +&#x3D; 增强赋值运算符达到类似的效果 a +&#x3D; 10; 先不要看 &#x3D; 号，获取 a 的原有值 30，执行加 10 运算，运算的结果 40 赋值给 a a -&#x3D; 10; 先拿 a 的原有值 40 与后面的 10 做减法，再将结果 30 赋值给 a 自增自减运算符 两个特殊运算符 ++ 与 – ++ 是让变量自增1，– 是让变量自减1，举个例子 int a &#x3D; 10; a++; 结果为 11，++ 和 – 既可以写在变量之前，也可以写在变量之后，这两种写法的区别，我们到高级篇再讲，目前暂不用去了解 4. 练习 - 房贷计算器【等额本息还款】法计算房贷 术语 等额本息是指一种贷款的还款方式，是在还款期内，每月偿还同等数额的贷款（包括本金和利息） 每月偿还的贷款可以通过下述公式计算$p * r * (1 + r)^m &#x2F; ((1 + r)^m - 1)$ p 为贷款本金 principal r 为月利率 monthlyInterestRate m 为还款月数 months 公式中这些都是什么意思呢 例如：贷款 200 万元 ，对应公式中的 p，200 万就是贷款本金，年利率 6%，月利率 mr 就是 6% &#x2F; 12 &#x3D; 0.5%，假设 10 年还清，这时还款月数就是 360 个月。套入公式计算即可得到每月还多少钱 要完成这个计算，有一点没学过的是求这里的 1+ mr 的 m 次方，计算它需要用一个求幂方法，这个方法是 jdk 核心类库中 Math 这个类提供的，Math的字面意思是数学，Math 类中提供了很多与数学计算相关的方法，如果你以后有这方面需求，就找它。 Math.pow()pow 是 static 方法，语法为 类名.方法名(参数值)，它需要两个参数，参数1是底数，参数2是指数 jshell&gt; Math.pow(2.0, 1) $42 &#x3D;&#x3D;&gt; 2.0 jshell&gt; Math.pow(2.0, 2) $43 &#x3D;&#x3D;&gt; 4.0 jshell&gt; Math.pow(2.0, 3) $44 &#x3D;&#x3D;&gt; 8.0 解答 打开 idea，编写 Calculator 类 public class Calculator { public static void main(String[] args) { Scanner scanner &#x3D; new Scanner(System.in); System.out.println(“请输入贷款本金 p”); double p &#x3D; scanner.nextDouble(); System.out.println(“请输入年利率 r%”); double yr &#x3D; scanner.nextDouble(); double mr &#x3D; yr &#x2F; 100.0 &#x2F; 12.0; System.out.println(&quot;请输入贷款月数 m&quot;); int m = scanner.nextInt(); System.out.println(p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1)); &#125; &#125; 数字格式化对结果的数字进行格式化，让它以货币的格式来显示 需要借助核心类库中一个 NumberFormat 对象，字面意思是数字格式化，使用它的 getCurrencyInstance 方法来获取一个货币格式化对象，再使用它的 format 方法把 double 小数格式化为货币格式，格式化时也会保留两位小数 例子 System.out.println(NumberFormat.getCurrencyInstance(Locale.CHINA).format(1000000.00)); System.out.println(NumberFormat.getCurrencyInstance(Locale.US).format(1000000.00)); System.out.println(NumberFormat.getCurrencyInstance(Locale.GERMANY).format(1000000.00)); System.out.println(NumberFormat.getCurrencyInstance(Locale.KOREA).format(1000000.00)); 输出 ¥1,000,000.00 $1,000,000.00 1.000.000,00 € ₩1,000,000 如果 Locale 省略不写，默认为中国 房贷计算器可以改写为 double payment &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1); System.out.println(NumberFormat.getCurrencyInstance().format(payment)); 查阅 Javadoc练习做完了，大家学到了什么呢？ 有同学说，学会怎么算每月还款了，是吗？并不是，通过这个例子，要认识到 java 核心类库能帮我们解决很多问题，比如说求幂运算，比如说数字格式化，包括之前学过的 Scanner 都是核心类库提供的功能，这就提醒我们，要解决某个编程问题之前，要先想一想核心类库有没有这方面的功能，如果有拿来用就行了，不必自己重新实现某项功能的代码，我们是站在巨人的肩膀上进行编程的。 当然，同学们并不是一开始就知道核心类库都提供了哪些功能，因此，这就需要我们不断去熟悉核心类库，熟悉它都有哪些类，哪些方法，比较重要的功能都在后续的课程中都会陆续介绍到，当然呢，同学们也不能总等着老师来喂知识，也可以自己查阅 javadoc 来扩展自己的知识面 javadoc 就是 java documentation 的缩写，我们下载的 jdk 中已经自带了，无需额外再下载。那怎么查阅 javadoc 呢，如果大家用的是 idea，那么可以通过一些快捷键来查阅java文档 比如想看看类的文档，这时先按 Ctrl + N 查找类，假设我想看 Math 类的文档，输入要查阅的类名 Math，回车，可以跳转到这个类 接下来我想看看方法的文档怎么办呢，按一下 ctrl + f12，列出当前类的所有方法，绿色表示可以使用方法，橙色带锁的，表示是该类一种特殊的私有方法，不能直接使用。找感兴趣的方法时，如果你懂一些英文单词，那么会有一定优势，例如你想找一个平方根方法，它对应的英文是 sqrt，这时敲入这几个字母，就会定位到方法，同样可以用翻译查看该方法的功能 可以查到它的作用：返回一个数的平方根，这是方法名，查看后面括号内可以得知，需要一个参数，代表要求平方根的那个数字，是一个double 小数，方法名称前还有个 double 表示它的结果类型也是一个 double 小数 Math 中的方法大部分都是 static 方法，也就是配合类名使用的方法，之前也说过，用法为 类名.方法名(参数) 在平时写代码时，如果忘记了某个方法的作用，可以光标定位到该方法，按 Ctrl + Q 进行查阅，效果是类似的 三. 条件语句编程时有一种重要的语句叫做条件语句，之前我们学过的都属于顺序语句，也就是从上至下，依次要执行每一行代码。 但是有的情况下，我们并不希望所有代码都执行，而是希望满足条件的代码才执行 例如：要对用户输入数据的合法性进行检查： 贷款本金必须大于0 贷款月数范围在 1 ~ 360 之间 年利率范围在 1% ~ 36% 之间 如果你输入的值连这些条件都不满足，有必要去计算每月还款金额吗？ 这种情况下，就要用到条件语句了，它的语法格式为 if(条件) { &#x2F;&#x2F; 条件为 true 执行这里 } else { &#x2F;&#x2F; 条件为 false 执行这里 } 什么意思呢，if 本意是如果，如果条件成立，执行代码1，else 本意是否则，即条件不成立，执行代码2，其中 else &#123; &#125; 语句块不是必须的，可以省略 那么条件这部分怎么写呢？对于数字类型可以借助比较运算符的运算结果来充当条件，参考下面的表格，这种表格列出了所有比较运算符 比较运算符 含义 a &#x3D;&#x3D; b 判断 a 与 b 是否相等 a &gt; b 判断 a 是否 &gt; b a &gt;&#x3D; b 判断 a 是否 &gt;&#x3D; b a &lt; b 判断 a 是否 &lt; b a &lt;&#x3D; b 判断 a 是否 &lt;&#x3D; b a !&#x3D; b 判断 a 与 b 是否不相等 1. boolean 类型判断的结果是布尔类型，可以充当条件，它的取值非真即假，真用 true 表示，假用 false 表示 2. 单条件jshell&gt; int a = 1000; a ==&gt; 1000 jshell&gt; if(a &gt; 0)&#123; ...&gt; System.out.println(&quot;ok&quot;); ...&gt; &#125; else &#123; ...&gt; System.out.println(&quot;必须&gt;0&quot;); ...&gt; &#125; ok jshell&gt; a = -1000; a ==&gt; -1000 jshell&gt; if(a &gt; 0)&#123; ...&gt; System.out.println(&quot;ok&quot;); ...&gt; &#125; else &#123; ...&gt; System.out.println(&quot;必须&gt;0&quot;); ...&gt; &#125; 必须&gt;0 房贷计算器改写如下 public static void main(String[] args) { Scanner scanner &#x3D; new Scanner(System.in); System.out.println(“请输入贷款本金 p”); double p &#x3D; scanner.nextDouble(); if(p &gt; 0) { System.out.println(“请输入年利率 r%”); double yr &#x3D; scanner.nextDouble(); double mr &#x3D; yr &#x2F; 100.0 &#x2F; 12.0; System.out.println(“请输入贷款月数 m”); int m &#x3D; scanner.nextInt(); double payment = p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1); System.out.println(NumberFormat.getCurrencyInstance().format(payment)); &#125; else &#123; System.out.println(&quot;贷款金额必须大于0&quot;); &#125; &#125; 3. 多条件刚才我们在判断贷款本金的时候，只需要有一个大于 0 的条件就可以了，但是接下来我们要去检查年利率的时候，他是在一个范围之间，这就必须有两个条件，一个条件呢是要让年利率大于等于 1%，第二个条件呢，是让上年利率必须小于等于 36%，而且呢这两个条件你必须同时成立 多个条件可以用逻辑运算符连接 逻辑运算符 含义 条件1 &amp;&amp; 条件2 &amp;&amp; 意思是并且，两个条件必须同时成立，结果为 true 条件1 \\ \\ 条件2 ! 条件 ! 意思是取反 举例 jshell&gt; int b &#x3D; 120; b &#x3D;&#x3D;&gt; 120 jshell&gt; if(b &gt;&#x3D; 1 &amp;&amp; b &lt;&#x3D; 360) { …&gt; System.out.println(“ok”); …&gt; } else { …&gt; System.out.println(“必须在1~360之间”); …&gt; } ok jshell&gt; b &#x3D; 0 b &#x3D;&#x3D;&gt; 0 jshell&gt; if(b &gt;= 1 &amp;&amp; b &lt;= 360) &#123; ...&gt; System.out.println(&quot;ok&quot;); ...&gt; &#125; else &#123; ...&gt; System.out.println(&quot;必须在1~360之间&quot;); ...&gt; &#125; 必须在1~360之间 jshell&gt; b = 361 b ==&gt; 361 jshell&gt; if(b &gt;= 1 &amp;&amp; b &lt;= 360) &#123; ...&gt; System.out.println(&quot;ok&quot;); ...&gt; &#125; else &#123; ...&gt; System.out.println(&quot;必须在1~360之间&quot;); ...&gt; &#125; 必须在1~360之间 房贷计算器改写如下 public static void main(String[] args) { Scanner scanner &#x3D; new Scanner(System.in); System.out.println(“请输入贷款本金 p”); double p &#x3D; scanner.nextDouble(); if(p &gt; 0.0) { System.out.println(“请输入年利率 r%”); double yr &#x3D; scanner.nextDouble(); if (yr &gt;&#x3D; 1.0 &amp;&amp; yr &lt;&#x3D; 36.0) { double mr &#x3D; yr &#x2F; 100.0 &#x2F; 12.0; System.out.println(“请输入贷款月数 m”); int m &#x3D; scanner.nextInt(); if (m &gt;&#x3D; 1 &amp;&amp; m &lt;&#x3D; 360) { double payment &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1); System.out.println(NumberFormat.getCurrencyInstance() .format(payment)); } else { System.out.println(“贷款月数范围在 1 ~ 360 之间”); } } else { System.out.println(“年利率范围在 1% ~ 36% 之间”); } } else { System.out.println(“贷款金额必须大于0”); } } 4. 相反条件我们这段代码，逻辑上没错，但你会发现不容易阅读 多层 if 嵌套导致代码的可读性变得很差，一旦大家写代码时出现了两层以上的 if 语句，就要小心了。如何改进呢？ 这里给同学们介绍一种方法：可以去除 else 提高代码可读性 比如，现在有两个分支，c 是一个条件，要么走分支1，要么走分支2，用下面的 if else 可以表示 if(c) { &#x2F;&#x2F; 分支1 } else { &#x2F;&#x2F; 分支2 } 等价于 if(!c) { &#x2F;&#x2F; 分支2 } else { &#x2F;&#x2F; 分支1 } 能不能不写 else 呢？假设进入了分支2，分支2的代码执行后，程序还会继续向下执行，导致分支1也被执行 if(!c) { &#x2F;&#x2F; 分支2 } &#x2F;&#x2F; 分支1 可以改写为下面的形式，这样就避免了 else 出现 if(!c) { &#x2F;&#x2F; 分支2 return; } &#x2F;&#x2F; 分支1 总结一下，以上代码的等价转换，有一句口诀：条件取反，if else 倒置，return 一加， else 可去 变换有一定的规律： 原条件 相反条件1 相反条件2 p &gt; 0.0 !(p &gt; 0.0) p &lt;&#x3D; 0.0 yr &gt;&#x3D; 1.0 &amp;&amp; yr &lt;&#x3D; 36.0 !(yr &gt;&#x3D; 1.0 &amp;&amp; yr &lt;&#x3D; 36.0) yr &lt; 1.0 \\ m &lt; 1 \\ \\ m &gt; 360 用逻辑与连接的两个条件，可以两个条件分别取反，然后&amp;&amp;变|| 年利率&gt;&#x3D;1.0 并且&lt;&#x3D;36.0 的相反条件是：年利率&lt;1.0 或者 年利率&gt;36.0 用逻辑或连接的两个条件，可以两个条件分别取反，然后||变&amp;&amp; 这种逻辑变换规律称之为反演规则，公式记不住没关系，简单的反演我们自己就能想出来，复杂的变换才用公式保证正确性 房贷计算器改写如下 public static void main(String[] args) { Scanner scanner &#x3D; new Scanner(System.in); System.out.println(“请输入贷款本金 p”); double p &#x3D; scanner.nextDouble(); if (p &lt;&#x3D; 0.0) { System.out.println(“贷款金额必须大于0”); return; } System.out.println(“请输入年利率 r%”); double yr &#x3D; scanner.nextDouble(); if (yr &lt; 1.0 || yr &gt; 36.0) { System.out.println(“年利率范围在 1% ~ 36% 之间”); return; } double mr &#x3D; yr &#x2F; 100.0 &#x2F; 12.0; System.out.println(“请输入贷款月数 m”); int m &#x3D; scanner.nextInt(); if (m &lt; 1 || m &gt; 360) { System.out.println(“贷款月数范围在 1 ~ 360 之间”); return; } double payment &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1); System.out.println(NumberFormat.getCurrencyInstance().format(payment)); } 四. 循环语句1. 循环语句语法for(初始化变量; 终止条件; 更新变量) &#123; // 循环体代码 &#125; 初始化部分仅执行一次 执行终止条件，如果为 true 继续循环，如果为 false 退出循环 执行循环体代码 执行迭代部分，从 2 开始执行 例如 for(int i &#x3D; 0; i &lt; 3; i++) { System.out.println(i); } 执行流程如下 声明一个变量 i，初始值为 0，用来控制循环次数 判断 i &lt; 3，此时 i 取值是 0，条件为 true，继续循环 System.out.println(0) i++，自增为 1 判断 i &lt; 3，此时 i 取值是 1，条件为 true，继续循环 System.out.println(1) i++，自增为 2 判断 i &lt; 3，此时 i 取值是 2，条件为 true，继续循环 System.out.println(2) i++，自增为 3 判断 i &lt; 3，此时 i 取值是 3，条件为 false，退出循环 2. 变量的作用范围上例中 i 的作用范围，仅在循环语句的 {} 内有效，现在要求求 1~100 的整数和，则需要把 sum 这个变量定义在 {} 外层 int sum &#x3D; 0; for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) { sum +&#x3D; i; } System.out.println(sum); 这里能否这样写 for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) { int sum &#x3D; 0; sum +&#x3D; i; } System.out.println(sum); 不行，变量有它们各自的作用范围，从变量的定义开始，找到包围它的，右 } 括号为止。 在它上面用它 在右括号外用它 3. 练习 - 贷款计算详情现在需要计算每月偿还的利息、偿还的本金、剩余的本金 例如，借款 1000 元，利息 100%，两月还清，根据公式计算出来每月还款 1333.33 月份 本月还款 偿还本金 偿还利息 剩余本金 1 1333.33 333.33 1000.00 666.67 2 1333.33 666.67 666.67 0 总额 2666.67 1000.00 1666.67 可以看到 $偿还利息 &#x3D; 剩余本金 * 月利率$ $偿还本金 &#x3D; 每月还款 - 偿还利息$ 房贷计算器改写如下 public static void main(String[] args) { Scanner scanner &#x3D; new Scanner(System.in); System.out.println(“请输入贷款本金 p”); double p &#x3D; scanner.nextDouble(); if (p &lt;&#x3D; 0.0) { System.out.println(“贷款金额必须大于0”); return; } System.out.println(“请输入年利率 r%”); double yr &#x3D; scanner.nextDouble(); if (yr &lt; 1.0 || yr &gt; 36.0) { System.out.println(“年利率范围在 1% ~ 36% 之间”); return; } double mr &#x3D; yr &#x2F; 100.0 &#x2F; 12.0; System.out.println(“请输入贷款月数 m”); int m &#x3D; scanner.nextInt(); if (m &lt; 1 || m &gt; 360) { System.out.println(“贷款月数范围在 1 ~ 360 之间”); return; } double payment &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1); System.out.println(NumberFormat.getCurrencyInstance().format(payment)); double totalInterest &#x3D; 0.0; &#x2F;&#x2F; 总利息 for (int i &#x3D; 1; i &lt;&#x3D; m; i++) { double interest &#x3D; p * mr; &#x2F;&#x2F; 每月偿还利息 double principal &#x3D; payment - interest; &#x2F;&#x2F; 每月偿还本金 p -&#x3D; principal; &#x2F;&#x2F; 剩余本金 totalInterest +&#x3D; interest; System.out.print(i); System.out.print(“\\t本月还款:” + NumberFormat.getCurrencyInstance().format(payment)); System.out.print(“\\t偿还本金:” + NumberFormat.getCurrencyInstance().format(principal)); System.out.print(“\\t偿还利息:” + NumberFormat.getCurrencyInstance().format(interest)); System.out.println(“\\t剩余本金:” + NumberFormat.getCurrencyInstance().format(p)); } System.out.print(“总还款额:” + NumberFormat.getCurrencyInstance().format(payment * m)); System.out.println(“\\t总利息:” + NumberFormat.getCurrencyInstance().format(totalInterest)); } 五. 方法将来代码多了，全部写在 main 方法里，会显得非常凌乱，难于阅读。这节课的目标是使用方法来改写前面的代码。 1. 定义方法先来了解一下定义方法的语法 [访问修饰符] [static] 返回结果类型 方法名([参数类型1 参数名1, 参数类型2 参数名2, …]) { &#x2F;&#x2F; 方法体 return 返回结果 } 其中用 [] 的（[] 不是语法的一部分）是可选部分 访问修饰符先省略不写，后面再讲 static 这里先写上，这个前面提过，用 static 修饰的方法不属于对象 方法执行完毕后可能会有返回结果 如果没有返回结果，返回值类型填写 void 如果有返回结果，填写实际的类型，例如 返回整数，填写 int 返回小数，填写 double 方法名随便起，但应当做到望文生义 参数是方法执行时需要传入的数据，可以有零到多个，格式为【参数类型 参数名】，多个参数之间用逗号分隔 {} 内写方法的具体代码 最后 return 用来结束方法的运行，如果方法有返回结果，也需要配合 return 把结果传递给调用者 例如，想计算一下两个整数的和 class Test { static int add(int a, int b) { return a + b; } } 2. 调用方法回忆一下 Math.pow(2.0, 2) 就是一个由 java 提供好的 static 方法，它怎么用呢，Math 是类名，pow 是方法名，括号内是参数，对于我们自己写的 static 方法，用法是类似的： 类名.方法名([参数值1, 参数值2, …]) 即 Test.add(100,200); 怎么拿到返回结果呢？ int c &#x3D; Test.add(100,200); 如果是调用本类 static 方法，可以省略前面的类名 3. 方法的意义学完了方法的定义、调用流程，再来看看方法的意义 方法的一个意义在于隐藏实现细节： 例如，对于前面例子中的【等额本息】方式计算房贷，如果没有方法，那就要求编程者必须非常清楚计算公式 double payment &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1); 假设有一位资深程序员（例如你）提供了计算房贷方法，那么编程者就只需要知道： 计算等额本金还款，需要一个名字叫calculate的方法 它需要三个参数，… ，至于具体的计算过程，被隐藏在了方法内部 double payment &#x3D; calculate(p, mr, m); p 贷款本金 mr 月利率 m 贷款月数 对于使用它的小白程序员来讲，无需了解它的实现细节，直接拿来用就可以了。小白程序员是站在你的肩膀上编程 方法的另一个意义在于减少重复代码、提高代码的可维护性： 对比以下代码，第一段是没用方法，如果有一处写错了，所有重复的地方都得修改 double p1 &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1); double p2 &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1); double p3 &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1); 用了方法，万一写错，只需要一个地方的代码需要修改 static double calculate(double p, double mr, int m) { return p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1); } 4. 练习 - 贷款计算 - 方法改写public class Calculator3 &#123; public static void main(String[] args) &#123; double p = inputAndCheckP(); double mr = inputAndCheckMr(); int m = inputAndCheckM(); double payment = Calculator3.calculate(p, mr, m); printDetails(p, mr, m, payment); &#125; static double inputAndCheckP() &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入本金&quot;); double p = scanner.nextDouble(); if(p &lt;= 0) &#123; // System.out.println(&quot;贷款金额必须 &gt; 0&quot;); // throw new 异常类型(&quot;提示信息&quot;) throw new IllegalArgumentException(&quot;贷款金额必须 &gt; 0&quot;); &#125; return p; &#125; static double inputAndCheckMr() &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入年利率&quot;); double yr = scanner.nextDouble(); if(yr &lt; 1.0 || yr &gt; 36.0) &#123; throw new IllegalArgumentException(&quot;年利率必须是 1 ~ 36&quot;); &#125; return yr / 12.0 / 100; &#125; static int inputAndCheckM() &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入还款月数&quot;); int m = scanner.nextInt(); if(m &lt; 1 || m &gt; 360) &#123; throw new IllegalArgumentException(&quot;贷款月数必须是 1 ~ 360&quot;); &#125; return m; &#125; static void printDetails(double p, double mr, int m, double payment) &#123; for (int i = 0; i &lt; m; i++) &#123; double payInterest = p * mr; // 偿还利息 double payPrincipal = payment - payInterest; // 偿还本金 p -= payPrincipal; // 剩余本金 System.out.print (&quot;月份:&quot; + (i + 1)); System.out.print(&quot;\\t本月还款:&quot; + NumberFormat.getCurrencyInstance().format(payment)); System.out.print(&quot;\\t偿还本金:&quot; + NumberFormat.getCurrencyInstance().format(payPrincipal)); System.out.print(&quot;\\t偿还利息:&quot; + NumberFormat.getCurrencyInstance().format(payInterest)); System.out.println(&quot;\\t剩余本金:&quot; + NumberFormat.getCurrencyInstance().format(p)); &#125; System.out.println(&quot;总还款额:&quot; + NumberFormat.getCurrencyInstance().format(payment * m)); &#125; ​ &#x2F;** * 以等额本息方式计算每月还款金额 * @param p 本金 * @param mr 月利率 * @param m 还款月数 * @return 每月还款金额 *&#x2F; static double calculate(double p, double mr, int m) { double pow &#x3D; Math.pow(1 + mr, m); return p * mr * pow &#x2F; (pow - 1); } } 说明1大家抽取方法时有一个原则，就是把一组完整功能，所对应的多行代码抽取为一个方法，这里我们把计算还款总额和计算还款详情，分别抽取了两个方法 calculate printDetails 抽取时，要点如下 方法名要见文知义 返回值不着急写，看看方法的外部需不需要用到这个方法内的变量 需要，返回值定义为结果类型 不需要，返回值定义为 void 参数也不着急写，看方法内缺哪些变量定义，以它们为方法参数 说明2对于 calculate 这种比较重要的方法定义，最好给它加一个文档，你得告诉将来这个方法的使用者，怎么用这个方法，每个参数是什么意思。 先写斜杠两个星号的开始，不用着急写它的结束，直接一回车。idea 就会自动生成一段 javadoc 文档，你可以在这里介绍方法的作用 在 @param 这里对每个参数进行说明 在 @return 这里对返回值进行说明。 说明3如果在某些验证不通过，想让剩余代码不要运行，可以利用 throw 语法 return 这种语法叫正常返回，也就是当方法调用后，代码还会继续运行 还有就是这种throw 语法，它称为异常返回，如果没有额外处理，代码从方法调用后就中断运行 六. package 与 jar1. package随着我们写的类越来越多，把他们都放在一块儿来管理，感觉比较的不规范，因此，我们要引入一个新的package语法，对源文件进行一个更好的管理。 其实这个package说白了就是Java中一种目录结构 |- 包1 |- 从属于包1 的类 |- 包2 |- 从属于包2 的类 语法： package 包名; &#x2F;&#x2F; 告诉下面的类从属于此包 class 类 { } 包的命名一般都是域名的倒置，如 baidu.com 域名的倒置就是 com.baidu bilibilicom 域名的倒置就是 com.bilibili 2. import与 package 关系非常密切的一个语法：import，如果你的类想使用另外一个类，而两个类不同包，这时就必须用 import，把另一个类导入进来才能使用 package com.itheima.a; import java.util.Scanner; class Calulator { public static void main(String[] args) { &#x2F;&#x2F; 要用到 Scanner, 这时就用用到上面的 import 语句 } } 有一种特殊情况不需要 import 导入，即 java.lang 包下的类使用时，都不需要 import 3. jar代码写完了，我们最终要发布成品吧，那是把源文件直接给使用者吗？显然不是吧。最终交给 jvm 运行的是 class 类文件，我们会把这多个 class 类文件打成一个压缩包，交付给用户。 用 idea 可以方便地打包 步骤1：创建工件（artifact）  步骤2：构建工件  步骤3：运行 jar 包，需要客户电脑上安装好 jdk java -jar jar包文件名","categories":[{"name":"编程","slug":"编程","permalink":"https://yanyi1991.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://yanyi1991.github.io/tags/Java/"}]},{"title":"Java基础","slug":"Java基础","date":"2024-04-10T12:06:48.000Z","updated":"2024-04-15T14:03:48.004Z","comments":true,"path":"2024/04/10/Java基础/","link":"","permalink":"https://yanyi1991.github.io/2024/04/10/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一. Java 简介Java 是第一大编程语言和开发平台。它有助于企业降低成本、缩短开发周期、推动创新以及改善应用服务。如今，Java 仍是企业和开发人员的首选开发平台，全球有数百万开发人员运行超过 51 亿台 Java 虚拟机。 1. JVM 它是 Java Virtual Machine 也就是 Java 虚拟机的缩写，它的职责是解释执行Java代码。我们写好的 Java 代码，并不能被直接运行，而是需要交给 JVM 来解释执行 很多公司都提供了 JVM 实现，最为知名的是 Oracle 提供的 JVM 实现 2. JRE JRE呢，是 Java runtime environment 的缩写，含义是 Java 的运行环境。Java 代码编写好了以后，不仅是需要 JVM 对它来进行解释，而且也需要一些基础功能的配合，这些基础功能呢，称之为核心类库（Core libraries），JVM 和核心类库加在一起，就构成了 JRE 这个运行环境 3. JDK JDK是 Java development kit 的缩写，含义是 Java 的开发环境。如果你不仅仅要运行 Java 程序，还想开发新的 Java 程序，那还需要借助一些开发工具，JRE 跟开发工具合在一起，就构成了JDK  通过刚才的讲解，我们了解到 JVM、JRE、JDK 之间是一个包含的关系： JDK 功能最全，包含了 JRE 和开发工具 其次是 JRE，包含了 JVM + 核心类库 最后是 JVM，负责解释执行我们的 Java 代码 因此，对于后面的学习，我们只需要下载安装 JDK 就可以进行 Java 开发了 从 Java 11 这个版本开始，不再单独提供 JRE In this release, the JRE or Server JRE is no longer offered. Only the JDK is offered. Users can use jlink to create smaller custom runtimes. 二. 安装 JDK1. 下载和安装这里介绍 Windows 10 平台下 Oracle 的 JDK 安装 入口在哪儿？访问 oracle 官网 Oracle | Cloud Applications and Cloud Platform  点击 Java 后进入下面的页面  下载页面让我们选择版本，这里选择 Java 17，因为它是长期支持版（LTS） 18 虽然看着新，但实际上到 2022.9 就会被 19 取代 而 17 的支持会到 2024 年 接下来选择平台，这里选择 Windows，其它平台下 JDK 的安装，请关注我们后续的视频 Windows 有三个版本，第一个是解压版，后两个是安装版。初学者我建议下载解压版（有助于理解 java 程序的查找过程）  下载完毕后，解压到一个没有中文和空格的目录即可 2. 配置 Path你可以选择一个喜欢的目录，我的解压目录是 d 盘根目录下，如图所示 其中 bin 目录下包含的就是它所带的一些开发和运行工具 像 Javac.exe 还有 Java.exe 都是较为重要的，后面都会用到  验证安装是否成功：按快捷键 Win + r，输入命令提示符程序名称 cmd  出现命令提示符窗口，输入 java -version C:\\Users\\Lenovo&gt;java ‘java’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。 这是因为 cmd 程序并不知道 java 的安装位置，因此没有找到它 可以输入它的全路径来找到它 比如，我的 java 解压到了 D:\\jdk-17.0.3.1 这个目录，这时全路径就是 D:\\jdk-17.0.3.1\\bin\\java 但显然这么做比较麻烦 更好的方式是配置 Path【环境变量】 按快捷键 win 搜索【此电脑】，出现下面的界面  点击【属性】，找到【高级系统设置】  按下图箭头顺序找到新建，把刚才 jdk 的解压目录 + bin 补充填入，我这里是 D:\\jdk-17.0.3.1\\bin，全部确定。  Path 环境变量的作用： Path 环境变量中记录的是程序执行时的搜索路径 cmd 执行一个程序时，即使未给出完整路径，也会在 Path 环境变量列出的目录下依次查找该程序 找到了，则执行 都找不到，才报错 因此对刚才的问题，只需将 java 程序的所在目录补充进 Path 环境变量 环境变量改动后，原有的 cmd 窗口是不受影响的，要想生效必须打开一个新的 cmd 窗口，输入 java -version，如果出现类似于下面的输出，表示成功 C:\\Users\\Lenovo&gt;java -version java version “17.0.2” 2022-01-18 LTS Java(TM) SE Runtime Environment (build 17.0.2+8-LTS-86) Java HotSpot(TM) 64-Bit Server VM (build 17.0.2+8-LTS-86, mixed mode, sharing) 3. 配置 JAVA_HOME（选讲）网上的一些教程，都会让大家配置另一个叫做 JAVA_HOME 的环境变量，代表的是 JDK 的安装根目录。 其实这个环境变量你可以不配，对于后续学习几乎没有影响 例外情况是，有的 java 程序，例如后面学到的 Tomcat 在启动时，会用到 JAVA_HOME 环境变量，但这属于个别现象，等我们学到它时再解决不迟 还有一个不配 JAVA_HOME 的理由：如果将来有不同的应用运行需要版本的 JDK，这时还不如不配全局 JAVA_HOME，让每个程序在启动脚本里指定自己需要的 JAVA_HOME 出于知识的完整性，我们演示一下如何配置 JAVA_HOME，还是找到环境变量的配置窗口，在系统环境变量处点击新建，输入变量名和变量值，JAVA_HOME 名称是固定的，注意全大写，值是 JDK 的安装根目录，我这里是 D:\\jdk-17.0.3.1 优化配完之后，发现 PATH 环境变量中的 D:\\jdk-17.0.3.1\\bin 与 JAVA_HOME 中的 D:\\jdk-17.0.3.1 有一部分重复了，这样的问题是如果将来切换 jdk 版本，如果改了一处，忘记改另一处，就会造成不一致。 可以把 PATH 的取值修改为 %JAVA_HOME%\\bin，其中 %JAVA_HOME% 代表引用 JAVA_HOME 环境变量的值，这样以后改动时，只需要改 JAVA_HOME 这一处就可以了 三. 入门案例这节课我们来学习 Java 的第一个入门程序，Hello world，目标是命令 jvm，在程序窗口输出一行问候语。 1. 第一行代码1) jshell首先用到的是一个名为 jshell 的开发工具，打开命令提示符 cmd，输入 jshell PS D:&gt; jshell | 欢迎使用 JShell – 版本 17.0.2 | 要大致了解该版本, 请键入: &#x2F;help intro jshell&gt; 可以看到【jshell&gt;】后的光标在不断闪烁，表示可以继续在【jshell&gt;】后键入命令或代码 常见命令 &#x2F;help 帮助信息 &#x2F;exit 退出 jshell 第一行代码来了：输入 System.out.println(&quot;Hello, world&quot;)，要注意大小写和引号，查看效果 2) 代码解读下面来解释这行代码的意思 它的整体效果是命令 JVM，给我在在程序窗口输出一行话，话的内容是：Hello, world 再来把代码拆解，看看每一部分的意思 先要说明的是，咱们这个程序窗口内有两个较为抽象的组成部分，输出和输入 其中输出的专业叫法是【标准输出】，用来将运算结果展现给用户，代码里就对应着 System.out 另一个是【标准输入】，用来接受用户输入的数据，代码里用 System.in 表示，后面再讲 System.out 、System.in 代表的这种计算机中的虚拟物体，以后统称之为【对象】 System.out 这个对象是 java 为我们提前准备好的 以后还有一些对象是需要我们自己创建的，后面会逐渐讲到 但是光是拿到 System.out 对象，它并不会显示 Hello, world，我们必须给它下命令，也就是调用对象的功能 println() 代表的是 System.out 中的一种功能，以后称之为【方法】 方法的特征是在使用时会带有一对 () 不同的方法作用不同，println 方法的作用是将 () 内的内容展现到程序窗口并换行，System.out 对象还有 print 方法，区别是不换行输出内容 前面的点，表示一种从属关系 即 println() 方法从属于 System.out 对象，print 方法也从属于 System.out 对象 从属关系决定了对象能否使用此方法，像 System.in 与 println 方法之间没有这种从属关系，就意味着 System.in 对象无法使用此 println 方法 想知道对象和哪些方法之间有从属关系，后面会给大家讲解怎么查，目前了解这些足够了 () 里面的 &quot;hello, world&quot; 叫做方法参数，你可以替换它为其它问候语 不同的方法需要的参数个数及格式也有所不同，刚才我们用的这个 println 方法只接收了一个参数，以后大家可能见到不同个数和格式的参数，这些后面都会详细讲解 总结从这行代码中学习了什么呀，要命令计算机执行功能，可以借助【对象】、【方法】和【参数】来完成 刚才的例子中谁是对象？ System.out 它代表什么？ 标准输出 谁是方法？ println 是方法 它有什么作用？ 不同方法作用不同，println 将括号内内容，也就是参数输出到程序窗口 这其中参数比较自由，由我们提供，可以是 hello, world, 可以是你好，也可以是其它问候语 对象和方法是 java 提供的（当然以后我们也可以自己创建对象，定义新的方法，此乃后话） 至此为止，这行代码的含义讲解完毕 3) 为何要分成对象与方法有同学问：Java的设计者搞个输出都这么麻烦，还分成对象和方法俩概念，把它们合为一个概念不是更简单吗？你看 对象用来表示被操作的物体，是名词 方法用来告知让这个物体执行什么动作，是动词 这种划分更符合现实世界中对事物的认知，例如，你叫住【皮卡丘】，皮卡丘就是待操作的对象，这时候他还不知道要做什么。好，你命令他【趴下】，这个趴下就是方法，是皮卡丘要执行的动作，你再命令他【吃饭】，这个吃饭是另一个方法。可以看到，现实世界都可以这么划分，那么把计算机中的虚拟物体抽象成对象和方法，当然也是顺理成章啦，这符合人类对事物的认知。 因此，不要怕麻烦，以后在 java 世界编写的代码，绝大多数都是这种对象+方法的形式，这称之为面向对象编程，今天我们还不会正式讲解面向对象编程，但同学们要建立起对象、方法的概念 2. 第一份源码jshell 执行过的代码，在 jshell 退出后下次再想用，就不方便调出来了，正式的代码都会保存在类文件中，类文件的后缀是 .java，也称为 java 源代码 1) 源码结构源码结构如下，一份源码中可以包含多个类，每个类中又可以包含多个方法，方法内再包含语句代码 class A { 方法1() { &#x2F;&#x2F; 语句代码 } 方法2() { &#x2F;&#x2F; 语句代码 } 入口方法() { &#x2F;&#x2F; 语句代码 } } class B { &#125; 这里我们关注其中一个特殊方法：入口方法。 入口方法的格式是固定的： public static void main(String[] args) { } 以后我们就称它为 main 方法 main 并不从属于任何对象（由 static 修饰） main 方法内就可以书写之前学过的那行代码 System.out.println(“Hello, world”) 要注意与之前 jshell 中一点区别是，这里的每行代码以分号结束 刚才给大家介绍了源代码的结构 源代码中可以包含多个 class 类，每个类中再去套方法，方法内再去套代码，当我们把这些写好之后，能不能交给 JVM 来执行呢？ 还不行，因为JVM不理解源码，需要通过 javac 开发工具把源代码编译成 class 字节码文件（这种字节码JVM可以理解）字节码文件的特点是后缀以 .class 结尾 最后再通过 java 工具可以将 class 字节码加载至 JVM，JVM 将字节码解释翻译为机器码，最终就可以由 CPU 执行啦。 2) 编写 java 源代码进入 d: 盘 目的是为了找到一个合适存储 java 源代码的位置，也可以是其他位置，总之方便你找到它 C:\\Users\\Lenovo&gt;d: D:&gt; 运行记事本程序，notepad 是记事本程序名称 D:&gt;notepad 会打开如下窗口  输入如下代码 class Hello { public static void main(String[] args) { System.out.println(“hello, world”); } } &quot;&quot; 内的 hello, world 是我们自由书写，可以是英文、汉字 class 后的 Hello 称之为【类名】，一般是英文单词 其余代码要与例子中的【完全一致】，并严格区分大小写 保存文件，选择 文件-&gt;保存 或按它对应的快捷键 Ctrl+S  类名与最后的文件名请保持一致，保存为文件名以 .java 结尾 保存文件时，确保也存储于 d: 盘，方便待会找到它 编码位置也要注意，可能会影响到汉字的输出，后面会讲 3) 编译 java 源代码关闭记事本程序，回到命令提示符程序，输入下面命令 D:&gt;javac Hello.java javac 用来把一个 *.java 文件编译成 *.class 文件 *.class 就是前面提到的 class 字节码 本例中，生成的字节码文件为 Hello.class，可以用 dir 命令查阅如下  4) 运行 class 字节码输入下面命令 D:&gt;java Hello hello, world java 命令用来把 Hello.class 加载到 JVM 并执行它 3. 常见问题中文输出乱码有的同学编写代码时用了中文 class Hello { public static void main(String[] args) { System.out.println(“你好”); } } 编译、执行后输出为 浣犲ソ 发音：huan chai so 原因在于，保存 Hello.java 文件时，选择了 UTF-8 编码，而 javac 编译时采用的是操作系统默认编码 GBK，只要两边编码不一致，就会发生上述的【乱码】问题 解决方法1保存文件时，选择编码为 ANSI（对于记事本程序 ANSI 其实就是 GBK）  解决方法2文件保存时，编码仍然是 UTF-8 不变，编译时改用下面的命令明确告诉编译器，编译时别用默认的 GBK，改用 UTF-8 D:&gt;javac -encoding utf-8 Hello.java 编译错误有的同学在执行 javac 时会遇到各种各样的问题，例如 D:&gt;javac -encoding utf-8 Hello.java Hello.java:3: 错误: 非法字符: ‘\\uff1b’ System.out.println(“你好”)； ^ 1 个错误 遇到这种错误不用怕 其中 Hello.java:3 意思是说，Hello.java 中第 3 行出现错误，这样就可以定位错误位置 接下来它又提示了具体错误原因：错误: 非法字符: &#39;\\uff1b&#39;，本例中是因为输入了中文分号 ；，java 语法要求语句结束符号是英文分号 ; 这些错误原因需要慢慢积累，见的多了就知道该怎么解决了 4. 注释注释就是对程序代码的一个说明，比如： 将来写的代码多了，你记性又没那么好，怕忘记某些代码的含义，这时候可以给它加一个注释 或是某些代码比较重要、特殊，这时也可以加一个注释进行说明 强调一点，注释只是对代码的说明，只影响代码阅读，不影响代码的功能。 注释的格式分成了单行注释，多行注释，还有文档注释三种。 单行注释写在被注释代码的上方或右方，格式为 &#x2F;&#x2F; 注释内容 多行注释如果注释内容比较长，都写在一行影响阅读，这时候就用多行注释，格式为 &#x2F;* 注释内容 注释内容 *&#x2F; 文档注释文档注释我们后面讲方法时再详细来讲吧，那现在呢，你只要了解它的格式：格式为： &#x2F;** 注释内容 *&#x2F; 5. 思考-为何需要字节码咱们先回忆一下 Java 程序的开发以及运行的流程 首先得编写一个Java的源文件，源文件编写好了就能交给CPU来执行吗？ 还不行啊，他得经过一个编译的步骤，也就是用那个javac程序把它编译成字节码文件 这个字节码文件呢，再经过一个叫 java 程序加载到 jvm 虚拟机， jvm 虚拟机其实还做了一件很重要的事，就是把字节码文件给解释成机器码 机器码就是最为底层的代码了，CPU就可以识别和运行它 所以整个流程是先把源文件变成字节码，再把字节码变成机器码，最终由CPU执行。 那这里大家可以思考这么一个问题，源代码，最终要变成机器码，是不是才能被CPU执行，那为什么我们不直接把Java 源码翻译成机器代码，而是多出了字节码这么一个中间环节呢？ C++ 的翻译过程要解释清楚这个问题啊，我们就必须介绍一点历史。在Java语言发明之前呢，有一个比较流行的编程语言叫做c++语言，这个c++语言它就没有中间的环节，可以把源文件直接他翻译成最终的机器码。有同学说这不挺好？但是呢有这么一个问题：不同平台下的这个机器码是不通用的。 举个例子，在windows平台下编写好了c++源代码，可以把它经编译器编译为windows平台的机器码，但是这个机器码呢，只能用在windows平台。想拿到Linux平台下用，用不了。必须在 Linux 平台下，重新编译成Linux机器码。看看这样的缺点 项目规模大了，源码编译也挺耗时间，在 windows 下编译一遍比如用了 20 分钟，测试通过了，将来要部署到 Linux 平台，又得编译一遍，再花 20 分钟… 时间都花在编译上了 程序员还得熟悉两个平台，做不到开发与部署环境相分离 说完了这是c++程序需要多次编译缺点，那咱们再来看看 Java 是怎么解决这个问题的。  Java 的翻译过程Java做的就是加入了字节码这个中间环节，不管是在Linux下的编译还是在windows下的编译，生成的字节码是所有平台都通用的，你在windows平台生成的字节码在Linux平台一样用，反之亦然。可以看到 编译只需要一次，编译时间被节省了 程序员只需要工作在自己熟悉的平台上就可以了，做到了开发与部署环境的分离 这就是 java 所宣称的 write once run anywhere，编写一次，到处运行。 字节码虽然带来了这样一些便利，但大家思考一下，有什么问题吗？ 对啦，问题就是字节码不是最终的机器码 需要在每个平台上安装 jvm 虚拟机，负责把字节码解释为机器码 另外因为引入了把字节码解释为机器码的步骤，性能上会有一定损失，当然 jvm 为了保证性能，内部会做很多优化，这等我们讲到 jvm 时，会有更深入的认识  小结通过初步对比 c++ 和 java 的不同编译策略，我们学习到一个词 trade-off，权衡。 c++ 直接编译生成机器码，性能无与伦比，但一旦改变平台，会带来额外的编译成本 java 编译生成字节码，减少编译成本，增强灵活性，但性能不可避免受到影响，需要再通过其它方面补救 以后大家如果进入到程序设计的领域，就会明白，所谓设计更多的是在各个方面做出权衡，没有最佳，只有最适合。 四. IDE 工具俗话说，工欲善其事，必先利其器，要准备好开发工具，才能提高开发效率。如果像开始那样，用记事本编写 java 代码，不仅慢，而且很容易出错。 首先来介绍 IDE 工具，IDE 即 Integrated Development Environment 集成开发环境，能够提供给开发者更好的编码、编译、测试环境 1. 常见 IDE 工具Eclipse老牌的 IDE 工具 Eclipse，有需要的同学可以根据下图下载尝试（Eclipse Downloads | The Eclipse Foundation）  它的特点是 完全免费 功能够用 Vscode以上两个工具属于重量级的 IDE 工具，如果想追求轻量级的工具，推荐使用 Visual Studio Code  它的特点有 完全免费 更为轻量，占用磁盘空间比 eclipse 和 idea 少很多，前面两个工具属于重量级 ide 工具 系出名门，微软开发 插件丰富，通过插件几乎可以支持所有语言 最后要介绍的一个 IDE 工具叫 Intellij IDEA，号称是最智能的 java 开发工具 IntelliJ IDEA新流行的 IDE 工具 IntelliJ IDEA，推荐大家用它（下载 IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE）  它有三个版本 Ultimate（最终版），功能最强，按年收费，价格不菲 Community（社区版），功能够用 如果你是在校学生，可以申请教育版 通过教育邮箱免费申请IntelliJ IDE全家桶教程 - 简书 (jianshu.com) 特点 更加智能 因为我不想花钱，下载的是社区版，另外我选择的这种zip压缩格式的安装包，它使用起来更加简单，解压就能用 使用步骤 选中下载好的压缩文件，解压，这里解压到 d：盘，注意保留后面的文件夹名称 进入d盘，进入解压目录中 bin子目录，找到一个名叫 idea64的程序双击，就可以运行了。 2. IntelliJ IDEA 的配置及使用本教程使用 IntelliJ IDEA Community 2022.1（截至本教程开始开发时的最新版本） 1) 安装启动首次运行，会弹出下面窗口  意思是是否导入以前的设置（settings），因为我们是第一次安装，所以就选择默认的不导入设置 出现 splash 欢迎页  接下来进入主界面  在学习 idea 之前，先来做几项简单的设置，可以改改颜色主题（Customize -&gt; Color theme）  如果选择 Sync with OS，意思就是根据操作系统改变主题（白天亮、夜晚暗）  推荐安装翻译插件，方便阅读文档  2) 创建项目创建新项目（Project）  在 IDEA 中【项目】和【模块】用来组织代码 一个【项目】（Project）包含多个【模块】（Module） 一个【模块】（Module）包含多个【源文件】 点击【新建项目】（New Project）后出现界面  其中 存储位置中的 ~ 代表当前用户目录 如我的 Windows 系统用户名为 Lenovo，则 ~ 对应目录为 C:\\Users\\Lenovo 你也可以选择其它目录来存储【项目】位置，但注意目录中不建议有中文和空格 语言这目前选择 Java，但要知道 JVM 还能运行其它几种语言：Kotlin 和 Groovy 项目类型目前选择 IntelliJ，后续我们还会学习 Maven 和 Gradle 如果安装了 JDK，会出现在这个下拉列表中 如果勾选了 Add sample code，则会生成一个简单的实例代码 点击 Create 按钮后  首次进入项目会在右下角显示两个弹窗通知  建议都点一下 前者能将 IntelliJ IDEA 的菜单中文化 后者能加速 IDEA 的使用速度 因为前面勾选了实例代码，因此 idea 已经帮我们生成了一个简单的源文件，看一下，里面已经包含了类、main 方法和一段 hello world 代码。 3) 运行代码 五. 实用工具1. Ubuntu 子系统如果用 Windows 操作系统，推荐安装 Linux 子系统，即 WSL 适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU&#x2F;Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销 官方安装文档：安装 WSL | Microsoft Docs 1) 安装 wsl 工具wsl --install 2) 安装 Ubuntu 子系统Ubuntu 是一种非常流行的 Linux 系统，打开微软应用商店  搜索 ubuntu  选一个版本安装（我用的是 18.04 LTS） 3) 运行 Ubuntu 子系统安装完毕后，打开命令提示符，输入 wsl，即可进入 Ubuntu 子系统  这里就可以运行各种 Linux 下的 App 了，当然我们主要用的是命令行下的 App，图形界面的 App 不行 2. 终端工具命令提示符这个工具虽然能用，但是界面比较 low，这里给大家介绍一款终端工具：Fluent Terminal，也是在微软应用商店搜索  运行界面如下  好处是同时支持三种终端 CMD（命令提示符） PowerShell（Windows 下另一个终端工具） WSL 3. 截图工具做笔记的神器：Snipaste，也是在微软应用商店搜索  4. 笔记工具笔记神器：Typora，1.0 版本后收费 89 元（可以找找低版本的），当然你也可以选择其它笔记工具  5. 思维导图工具推荐使用 Xmind 工具，免费的功能就够用","categories":[{"name":"编程","slug":"编程","permalink":"https://yanyi1991.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://yanyi1991.github.io/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-04-09T15:42:07.353Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2024/04/09/hello-world/","link":"","permalink":"https://yanyi1991.github.io/2024/04/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://yanyi1991.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"编程","slug":"编程","permalink":"https://yanyi1991.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://yanyi1991.github.io/tags/STM32/"},{"name":"Java","slug":"Java","permalink":"https://yanyi1991.github.io/tags/Java/"}]}
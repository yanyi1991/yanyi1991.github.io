<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024-2025进程安排</title>
      <link href="/2024/10/17/2024-2025%E8%BF%9B%E7%A8%8B%E5%AE%89%E6%8E%92/"/>
      <url>/2024/10/17/2024-2025%E8%BF%9B%E7%A8%8B%E5%AE%89%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<p>1.嵌入式仿真大赛（已经结束）</p><p>2.软件学院第二届嵌入式系统设计竞赛-STM32智能宠物（正在进行）预计12月16日</p><p>3.第十六届全国大学生数学竞赛（正在进行）预计11月9日</p><p>4.第六届全国高校计算机能力挑战赛-python赛道（正在进行）预计11月17日</p><p>5.英语四级（正在进行）预计12月14日</p><p>6.蓝桥杯（明年）</p><p>7.软考-软件设计师（明年）</p><p>8.职业生涯规划大赛（正在进行）预计11月15校赛</p><p>9.2024“冰雪杯”全国大学生外语能力大赛（正在进行）预计10月20日截止</p><p>10.简历制作（正在进行）</p><p>11.传智杯（正在进行）2024年11月</p><p>12.华为ICT大赛-网络赛道（正在进行）</p><p>13.互联网技能应用赛（12.3公布初赛排名）</p><p>14.计算机学会学生会员（已入会）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>绪论</title>
      <link href="/2024/08/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2024/08/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-嵌入式系统定义"><a href="#1-嵌入式系统定义" class="headerlink" title="1.嵌入式系统定义"></a>1.嵌入式系统定义</h2><p>国际定义：根据（IEEE）将嵌入式系统定义为用于控制、监视或者辅助操作机器和设备的装置–主要根   据其应用对象方式定义</p><p>国内定义：嵌入式系统是一个具有特殊功能和用途的计算机软硬件集合体–以系统的应用为中心，计算机技术为基础，软件与硬件的结合的专用计算机系统，此系统对功能、可靠性、成本、体积、功能具有严格要求</p><h2 id="2-嵌入式系统的特点"><a href="#2-嵌入式系统的特点" class="headerlink" title="2.嵌入式系统的特点"></a>2.嵌入式系统的特点</h2><p>专用型  实时性  生命周期长  小体积、低功耗  低成本  高稳定性  不可垄断性  </p><h2 id="3-嵌入式系统的应用"><a href="#3-嵌入式系统的应用" class="headerlink" title="3.嵌入式系统的应用"></a>3.嵌入式系统的应用</h2><p>消费电子  工业控制  网络应用  军用领域</p><h2 id="4-通用机与嵌入式系统区别"><a href="#4-通用机与嵌入式系统区别" class="headerlink" title="4.通用机与嵌入式系统区别"></a>4.通用机与嵌入式系统区别</h2><h3 id="PC机系统："><a href="#PC机系统：" class="headerlink" title="PC机系统："></a>PC机系统：</h3><p>硬件：主机（CPU、主板、内存条、显卡）、显示器</p><p>软件：相对独立（可安装&#x2F;拆卸）</p><p>操作系统：Windows Linux iOS</p><h3 id="嵌入式系统："><a href="#嵌入式系统：" class="headerlink" title="嵌入式系统："></a>嵌入式系统：</h3><p>硬件：MCU（将CPU、ROM-只读存储器、RAM-随机存储器、定时器、I&#x2F;O接口集成在一片芯片上，形成芯片级计算机）、显示屏</p><p>软件：集成&#x2F;固化在芯片中，用户不能更改</p><p>操作系统：Linux、winCE、Android</p><h3 id="SOC（片上系统）"><a href="#SOC（片上系统）" class="headerlink" title="SOC（片上系统）"></a>SOC（片上系统）</h3><p>以处理器为核心，加上外围功能（集成USB、ADC&#x2F;DAC、以太网模块）的芯片，称为SOC片上系统</p><h3 id="处理器分类"><a href="#处理器分类" class="headerlink" title="处理器分类"></a>处理器分类</h3><p><u>嵌入式处理器</u>  </p><p>是嵌入式系统的核心，是控制，辅助系统运行的硬件单元。目前可以分为：嵌入式微控制器（MCU），嵌入式微处理器（MPU），嵌入式DSP，嵌入式SoC（FPGA）</p><p><u>通用处理器</u></p><p>是以x86（x86文件）体系架构的被INTEL和AMD两家公司垄断，追求更快的运算速度、更大的数据吞吐量、有32、64位处理器等</p><p><u>嵌入式微控制器（MCU）</u></p><p>又称单片机，典型的MCU厂商有：ST（意法半导体）、TI（德州仪器）等</p><p><u>嵌入式微处理器（MPU）</u></p><p>由CPU演变而来，增强版的CPU，主要有：麒麟、A处理器、三星、高通等</p><p><u>嵌入式DSP</u></p><p> 主要专门用于信号处理方面，为了追求高执行效率，不适合运行操作系统，核心代码使用汇编</p><p><u>嵌入式SoC（FPGA）</u></p><p>可编程逻辑技术把整个系统放到一块硅片上，称作SOC，如Altera公司的FPGA 芯片、 Xilinx公司的FPGA芯片</p><p><u>ARM处理器</u></p><p>ARM处理器占据了低功耗、低成本和高性能的嵌入式系统应用的大部分领域，特别是在移动市场，ARM处理器基本处于垄断地位，当前的智能手机的处理器基本都是各公司购买的ARM处理器内核开发出来的。</p><p>Cortex系列处理器：ARM公司在经典处理器<strong>ARM11</strong>以后的产品都改用<strong>Cortex</strong>命名，并分成A、R和M三类。</p><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><p><u>随机存取存储器（RAM）</u></p><p> 存储单元的内容可按需随意取出或存入，读写速度很快，且速度与存储单元的位置无关。RAM在断电时将丢失其存储内容，RAM主要用于存储短时间使用的程序。</p><p><u>静态随机存取存储器（Static Random Access Memory，SRAM）</u></p><p><u>动态随机存取存储器（Dynamic Random Access Memory，DRAM）</u></p><p><u>同步动态随机存储器（Synchronous Dynamic Random Access Memory，SDRAM）</u></p><p><u>只读存储器（ROM）</u></p><p> 只读存储器中的数据可以在掉电后不丢失，ROM主要用于存储程序和一些数据（常量、系数等），存储在其中的数据只能读不能改；同时还存在一种需要使用特定的方法擦除和烧录数据的ROM，及电可擦除可编程ROM（EEPROM）</p><p><u>闪存存储器（FLASH）</u></p><p>闪存存储器是电可擦除的ROM，在使用上与EEPROM类似。但是二者的寻址方法不同，存储单元的结构也不同，Flash存储器的电路结构较简单，同样容量占芯片面积较小，成本比EEPROM低。常见固态硬盘和优盘都是闪存存储器。</p><p><strong>嵌入式软件开发主要有两种方式</strong></p><p>直接在芯片上进行应用开发   在芯片上运行操作系统</p><p>嵌入式系统软件结构一般包含3个层面：<strong>设备驱动层</strong>、<strong>OS层</strong>、<strong>应用层</strong></p><p>嵌入式操作系统可以分为<u>嵌入式非实时操作系统</u>和<u>嵌入式实时操作系统</u>（<strong>RTOS</strong>）</p><h3 id="嵌入式系统的发展历程"><a href="#嵌入式系统的发展历程" class="headerlink" title="嵌入式系统的发展历程"></a>嵌入式系统的发展历程</h3><p>单片机时代（1970年代末）</p><p>微控制器时代（1980年代）</p><p>嵌入式操作系统时代（1990年代）</p><p>嵌入式处理器时代（2000年代至今）</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式·第一章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="/2024/06/18/%E5%AE%9E%E9%AA%8C%E4%B8%83-Servlet/"/>
      <url>/2024/06/18/%E5%AE%9E%E9%AA%8C%E4%B8%83-Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务一"><a href="#实验任务一" class="headerlink" title="实验任务一"></a>实验任务一</h1><pre><code class="java">GetParameterTest.java</code></pre><pre><code class="java">import java.io.*;  import javax.servlet.ServletConfig;  import javax.servlet.annotation.WebServlet;  import javax.servlet.http.HttpServlet;  import javax.servlet.http.HttpServletRequest;  import javax.servlet.http.HttpServletResponse;  @WebServlet(name = &quot;GetParameterTest&quot;, value = &quot;/GetParameterTest&quot;)  public class GetParameterTest extends HttpServlet &#123;      @Override      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;          response.setContentType(&quot;text/html;charset=utf-8&quot;);          PrintWriter out = response.getWriter();          ServletConfig config = this.getServletConfig();          String author = config.getInitParameter(&quot;author&quot;);          String school = config.getInitParameter(&quot;school&quot;);          String name = config.getInitParameter(&quot;Servlet名&quot;);          out.println(&quot;school：&quot;+school+&quot;&lt;br&gt;&quot;);          out.println(&quot;author：&quot;+author+&quot;&lt;br&gt;&quot;);          out.println(&quot;Servlet名：&quot;+name+&quot;&lt;br&gt;&quot;);      &#125;      @Override      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;     &#125;&#125;</code></pre><pre><code class="java">web.xml</code></pre><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;GetParameterTest&lt;/servlet-name&gt;    &lt;servlet-class&gt;MyServlet.GetParameterTest&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;author&lt;/param-name&gt;        &lt;param-value&gt;陈彩华&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;school&lt;/param-name&gt;        &lt;param-value&gt;湖南广播电视大学&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;Servlet名&lt;/param-name&gt;        &lt;param-value&gt;GetParameterTest&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;GetParameterTest&lt;/servlet-name&gt;    &lt;url-pattern&gt;/GetParameterTest&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><h1 id="实验任务二"><a href="#实验任务二" class="headerlink" title="实验任务二"></a>实验任务二</h1><pre><code>GetWebParameter.java</code></pre><pre><code class="java">import java.io.*;import javax.servlet.ServletContext;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;GetWebParameter&quot;, value = &quot;/GetWebParameter&quot;)public class GetWebParameter extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        ServletContext context = this.getServletContext();        out.println(&quot;Web项目的所有参数如下&quot;+&quot;&lt;br&gt;&quot;);        out.println(&quot;first：&quot; + context.getInitParameter(&quot;first&quot;) + &quot;&lt;br&gt;&quot;);        out.println(&quot;second：&quot; + context.getInitParameter(&quot;second&quot;));    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;    &#125;&#125;</code></pre><pre><code class="xml">web.xml</code></pre><pre><code class="xml">&lt;context-param&gt;    &lt;param-name&gt;first&lt;/param-name&gt;    &lt;param-value&gt;这是第一个参数的值&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt;    &lt;param-name&gt;second&lt;/param-name&gt;    &lt;param-value&gt;这是第二个参数的值&lt;/param-value&gt;&lt;/context-param&gt;</code></pre><h1 id="实验任务三"><a href="#实验任务三" class="headerlink" title="实验任务三"></a>实验任务三</h1><pre><code class="java">ShareParameterA</code></pre><pre><code class="java">import java.io.*;import javax.servlet.ServletConfig;import javax.servlet.ServletContext;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;ShareParameterA&quot;, value = &quot;/ShareParameterA&quot;)public class ShareParameterA extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        ServletConfig config = this.getServletConfig();        ServletContext context = this.getServletContext();        context.setAttribute(&quot;a1&quot;,config.getInitParameter(&quot;a&quot;));    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;    &#125;&#125;</code></pre><pre><code class="java">ShareParameterB</code></pre><pre><code class="java">import java.io.*;import javax.servlet.ServletContext;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;ShareParameterB&quot;, value = &quot;/ShareParameterB&quot;)public class ShareParameterB extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        ServletContext context = this.getServletContext();        out.println(context.getAttribute(&quot;a1&quot;));    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;    &#125;&#125;</code></pre><h1 id="实验任务四"><a href="#实验任务四" class="headerlink" title="实验任务四"></a>实验任务四</h1><pre><code class="java">data.properties</code></pre><pre><code class="properties">address=ChangShaschool=HXX</code></pre><pre><code class="java">GetResourceServlet</code></pre><pre><code class="java">import java.io.*;import java.util.Properties;import javax.servlet.ServletContext;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;GetResourceServlet&quot;, value = &quot;/GetResourceServlet&quot;)public class GetResourceServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        ServletContext context=getServletContext();        String path=context.getRealPath(&quot;data.properties&quot;);        FileInputStream fis=new FileInputStream(path);        Properties pros=new Properties();        pros.load(fis);        String address=pros.getProperty(&quot;address&quot;);        String school=pros.getProperty(&quot;school&quot;);        out.println(&quot;地址：&quot;+address+&quot;&lt;br&gt;&quot;);        out.println(&quot;学校：&quot;+school);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;    &#125;&#125;</code></pre><h4 id="注：这么详细的配置还看不懂的话，抓紧退学"><a href="#注：这么详细的配置还看不懂的话，抓紧退学" class="headerlink" title="注：这么详细的配置还看不懂的话，抓紧退学"></a>注：这么详细的配置还看不懂的话，抓紧退学</h4>]]></content>
      
      
      <categories>
          
          <category> 实验七 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> html </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过滤器</title>
      <link href="/2024/05/29/%E5%AE%9E%E9%AA%8C%E5%85%AB-%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2024/05/29/%E5%AE%9E%E9%AA%8C%E5%85%AB-%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务一"><a href="#实验任务一" class="headerlink" title="实验任务一"></a>实验任务一</h1><p>MyServlet.java</p><pre><code class="java">import java.io.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;MyServlet&quot;, value = &quot;/MyServlet&quot;)public class MyServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        out.println(&quot;Servlet程序!&quot;+&quot;&lt;br&gt;&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;    &#125;&#125;</code></pre><p>MyFilter.java</p><pre><code class="java">import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;import java.io.PrintWriter;@WebFilter(&quot;&quot;)public class MyFilter implements Filter &#123;    @Override    public void destroy() &#123;    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        out.println(&quot;Filter程序！&quot;+&quot;&lt;br&gt;&quot;);    &#125;    @Override    public void init(FilterConfig config) &#123;    &#125;&#125;</code></pre><p>web.xml</p><pre><code class="java">    &lt;filter&gt;        &lt;filter-name&gt;MyFilter&lt;/filter-name&gt;        &lt;filter-class&gt;Experiment8.MyFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;MyFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;</code></pre><h1 id="实验任务二"><a href="#实验任务二" class="headerlink" title="实验任务二"></a>实验任务二</h1><p>first.jsp</p><body><pre><code class="html">&lt;h1&gt; 这是JSP页面 &lt;/h1&gt;</code></pre></body><p>ForwardServlet.java</p><pre><code class="java">import java.io.*;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;ForwardServlet&quot;, value = &quot;/ForwardServlet&quot;)public class ForwardServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;        request.getRequestDispatcher(&quot;Experiment8/first.jsp&quot;).forward(request,response);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;    &#125;&#125;</code></pre><p>ForwardFilter.java</p><pre><code class="java">import java.io.PrintWriter;@javax.servlet.annotation.WebFilter(&quot;&quot;)public class ForwardFilter implements javax.servlet.Filter &#123;    @Override    public void destroy() &#123;    &#125;    @Override    public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws javax.servlet.ServletException, java.io.IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        out.println(&quot;这是过滤器程序！&quot;+&quot;&lt;br&gt;&quot;);    &#125;    @Override    public void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException &#123;    &#125;&#125;</code></pre><p>web.xml</p><pre><code class="java">    &lt;filter&gt;        &lt;filter-name&gt;ForwardFilter&lt;/filter-name&gt;        &lt;filter-class&gt;Experiment8.ForwardFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;ForwardFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/Experiment8/first.jsp&lt;/url-pattern&gt;        &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;    &lt;/filter-mapping&gt;</code></pre><h1 id="实验任务三"><a href="#实验任务三" class="headerlink" title="实验任务三"></a>实验任务三</h1><p>Filter01.java</p><pre><code class="java">import java.io.PrintWriter;@javax.servlet.annotation.WebFilter(&quot;&quot;)public class Filter01 implements javax.servlet.Filter &#123;    @Override    public void destroy() &#123;    &#125;    @Override    public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws javax.servlet.ServletException, java.io.IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        out.println(&quot;第一个过滤器之前！&lt;br&gt;&quot;);        chain.doFilter(request, response);        out.println(&quot;第一个过滤器之后！&lt;br&gt;&quot;);    &#125;    @Override    public void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException &#123;    &#125;&#125;</code></pre><p>Filter02.java</p><pre><code class="java">import java.io.PrintWriter;@javax.servlet.annotation.WebFilter(&quot;&quot;)public class filter02 implements javax.servlet.Filter &#123;    @Override    public void destroy() &#123;    &#125;    @Override    public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws javax.servlet.ServletException, java.io.IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        out.println(&quot;第二个过滤器之前！&lt;br&gt;&quot;);        chain.doFilter(request, response);        out.println(&quot;第二个过滤器之后！&lt;br&gt;&quot;);    &#125;    @Override    public void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException &#123;    &#125;&#125;</code></pre><p>FilterChainServlet.java</p><pre><code class="java">import java.io.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;FilterChainServlet&quot;, value = &quot;/FilterChainServlet&quot;)public class FilterChainServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        out.println(&quot;这是过滤器链拦截的Servlet！&lt;br&gt;&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;    &#125;&#125;</code></pre><p>web.xml</p><pre><code class="java">&lt;filter&gt;    &lt;filter-name&gt;Filter01&lt;/filter-name&gt;    &lt;filter-class&gt;Experiment8.Filter01&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;Filter01&lt;/filter-name&gt;    &lt;url-pattern&gt;/FilterChainServlet&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter&gt;    &lt;filter-name&gt;Filter02&lt;/filter-name&gt;    &lt;filter-class&gt;Experiment8.filter02&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;Filter02&lt;/filter-name&gt;    &lt;url-pattern&gt;/FilterChainServlet&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><h1 id="实验任务四"><a href="#实验任务四" class="headerlink" title="实验任务四"></a>实验任务四</h1><p>filterForm.jsp</p><body><pre><code class="html">&lt;form action=&quot;DealWithServlet&quot; method=&quot;post&quot;&gt;    &lt;label&gt;        请输入学生信息的模糊资料：&lt;input type=&quot;text&quot; name=&quot;information&quot;&gt;    &lt;/label&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;&lt;/form&gt; </code></pre></body><p>DealWithServlet.java</p><pre><code class="java">import java.io.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;DealWithServlet&quot;, value = &quot;/Experiment8/DealWithServlet&quot;)public class DealWithServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        String information = request.getParameter(&quot;information&quot;);        PrintWriter out = response.getWriter();        out.println(&quot;学生姓名：&quot; + information);    &#125;&#125;</code></pre><p>EncodingFilter.java</p><pre><code class="java">@javax.servlet.annotation.WebFilter(&quot;&quot;)public class EncodingFilter implements javax.servlet.Filter &#123;    @Override    public void destroy() &#123;    &#125;    @Override    public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws javax.servlet.ServletException, java.io.IOException &#123;        request.setCharacterEncoding(&quot;UTF-8&quot;);        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        chain.doFilter(request, response);    &#125;    @Override    public void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException &#123;    &#125;&#125;</code></pre><p>web.xml</p><pre><code class="java">&lt;filter&gt;    &lt;filter-name&gt;EncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;Experiment8.EncodingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;EncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 实验八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> html </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2024/05/29/%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/05/29/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<hr><p><img src="https://gitee.com/yanyi-2004/picbed/raw/master/img/202504131552928.jpeg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32_Day2</title>
      <link href="/2024/04/16/stm32-Day2/"/>
      <url>/2024/04/16/stm32-Day2/</url>
      
        <content type="html"><![CDATA[<h1 id="Nucleo开发板外围电路设计"><a href="#Nucleo开发板外围电路设计" class="headerlink" title="Nucleo开发板外围电路设计"></a>Nucleo开发板外围电路设计</h1><h2 id="1．指示灯电路（高电平-低电平驱动）"><a href="#1．指示灯电路（高电平-低电平驱动）" class="headerlink" title="1．指示灯电路（高电平&#x2F;低电平驱动）"></a>1．指示灯电路（高电平&#x2F;低电平驱动）</h2><p>高电平：指示灯的负极接地，指示灯的正极通过限流电阻Rs和GPIO引脚连接（引脚输出高电平开启／低电平关闭）</p><p>低电平：指示灯的负极与GPIO引脚连接（引脚输出高电平关闭／低电平开启），指示灯的正极通过限流电阻 Rs与电源连接</p><p>在Nucleo开发板上，用 PA5引脚控制指示灯（采用高电平驱动方式）</p><h2 id="2．按键电路的设计（上拉式按键-下拉式按键）"><a href="#2．按键电路的设计（上拉式按键-下拉式按键）" class="headerlink" title="2．按键电路的设计（上拉式按键&#x2F;下拉式按键）"></a>2．按键电路的设计（上拉式按键&#x2F;下拉式按键）</h2><p>上拉式按键：一端与地相连，另外一端通过上拉电阻与电源连接，按键按下（下降沿），IO口读到低电平</p><p>下拉式按键：一端与电源相连，另外一端通过下拉电阻接地，按键按下（上升沿），IO口读到高电平</p><p>在Nucleo开发板上，用 PA13引脚控制按键（采用上拉式按键方式）</p><h2 id="3．外扩接口的设计（Arduino-Uno-ST-morpho）"><a href="#3．外扩接口的设计（Arduino-Uno-ST-morpho）" class="headerlink" title="3．外扩接口的设计（Arduino Uno&#x2F;ST morpho）"></a>3．外扩接口的设计（Arduino Uno&#x2F;ST morpho）</h2><p>Arduino Uno：CN5&#x2F;CN6&#x2F;CN8&#x2F;CN9（单排插孔）</p><p><img src="https://cui1225.oss-cn-beijing.aliyuncs.com/img/image-20240416213816539.png" alt="image-20240416213816539"></p><p><img src="https://cui1225.oss-cn-beijing.aliyuncs.com/img/image-20240416214212648.png" alt="image-20240416214212648"></p><p>ST morpho：CN7&#x2F;CN10（双排插针）</p><p><img src="https://cui1225.oss-cn-beijing.aliyuncs.com/img/image-20240416214310377.png" alt="image-20240416214310377"></p><p>注：外扩时不要使用PA5这个引脚</p><p><img src="https://cui1225.oss-cn-beijing.aliyuncs.com/img/image-20240416214338003.png" alt="image-20240416214338003"></p><p>注：外扩时不要使用PA3和PA2两个引脚</p><h2 id="4．与外界扩展版的连接方式（利用接口以层叠的形式进行连接-利用杜邦线进行连接外围模块）"><a href="#4．与外界扩展版的连接方式（利用接口以层叠的形式进行连接-利用杜邦线进行连接外围模块）" class="headerlink" title="4．与外界扩展版的连接方式（利用接口以层叠的形式进行连接&#x2F;利用杜邦线进行连接外围模块）"></a>4．与外界扩展版的连接方式（利用接口以层叠的形式进行连接&#x2F;利用杜邦线进行连接外围模块）</h2><p><img src="https://cui1225.oss-cn-beijing.aliyuncs.com/img/image-20240416214711499.png" alt="image-20240416214711499"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32_Day1</title>
      <link href="/2024/04/14/stm32-Day1/"/>
      <url>/2024/04/14/stm32-Day1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-STM32-Nucleo开发板简介"><a href="#1-STM32-Nucleo开发板简介" class="headerlink" title="1.STM32 Nucleo开发板简介"></a>1.STM32 Nucleo开发板简介</h1><h2 id="1-官方开发板"><a href="#1-官方开发板" class="headerlink" title="1.官方开发板"></a>1.官方开发板</h2><p>1.Nucleo Borad（灵活搭建产品原型，使用最为广泛）</p><p>2.Discovery Kit（针对芯片的重要性能进行参考评估）</p><p>3.Evaluation Board（功能最为强大，可以对芯片的全部功能进行参考评估）</p><h2 id="2-Nucleo开发板电路特点"><a href="#2-Nucleo开发板电路特点" class="headerlink" title="2.Nucleo开发板电路特点"></a>2.Nucleo开发板电路特点</h2><p>1.模块化的设计（ST-Link仿真器+MCU核心板）</p><p>2.统一的MCU核心板设计（一板多用）</p><p>3.丰富的接口拓展（Arduino生态）</p><p>4.简洁的外设模块（指示灯和按键）</p><p>5.多功能的USB接口（虚拟串口，大容量存储，调试接口）</p><p>6.灵活的供电方式（USB供电，外部供电）</p><p>7.支出多种开发环境（MDK-ARM，EWARM，Mbed）</p><p><img src="https://gitee.com/yanyi-2004/picbed/raw/master/img/202504122132052.jpeg"></p><p>最大的优势就是提供了ARDUINO的扩展接口</p><h2 id="3-按照引脚数量来分类-系列"><a href="#3-按照引脚数量来分类-系列" class="headerlink" title="3.按照引脚数量来分类(系列)"></a>3.按照引脚数量来分类(系列)</h2><p>1.Nucleo32</p><p>2.Nucleo64</p><p>3.Nucleo144</p><p><img src="https://cui1225.oss-cn-beijing.aliyuncs.com/img/19c4dacb-fbcd-44bc-affb-8e816442e7f0.png" alt="19c4dacb-fbcd-44bc-affb-8e816442e7f0"></p><p>上半部分（ST-Link仿真器）</p><p>下半部分（MCU核心板）</p><h2 id="4-电路模块"><a href="#4-电路模块" class="headerlink" title="4.电路模块"></a>4.电路模块</h2><p>CN4：SWD调试接口</p><p>B1：用户按键</p><p>LD3：电源指示灯</p><p>主控芯片：STM32F411RET</p><p>CN7：外扩引脚接口（便于用户二次开发）</p><p>CN1：USB接口</p><p>B2：复位按键</p><p>LD2：用户指示灯</p><p>CN5&#x2F;6&#x2F;8&#x2F;9：Arduino接口</p><p>CN10：外扩引脚接口（便于用户二次开发）</p><h2 id="5-STM32F411RET6-片内资源"><a href="#5-STM32F411RET6-片内资源" class="headerlink" title="5.STM32F411RET6 片内资源"></a>5.STM32F411RET6 片内资源</h2><p>存储器方面：512KB Flash 和 128KB SRAM</p><p>定时器方面：1个16位高级定时器，2个32位通用定时器，5个16位通用定时器</p><p>连接接口方面：3路USART（串口），5路SPI&#x2F;I2S，3路I2C，1路SDIO</p><p>AD采集方面：1路12位16通道ADC</p><p>USB接口方面：1个全速USB 2.0 OTG</p><p>数字IO数量方面：50个通用数字I&#x2F;O口</p><h2 id="6-主控芯片的引脚-5大类"><a href="#6-主控芯片的引脚-5大类" class="headerlink" title="6.主控芯片的引脚(5大类)"></a>6.主控芯片的引脚(5大类)</h2><h3 id="1-电源引脚"><a href="#1-电源引脚" class="headerlink" title="1.电源引脚"></a>1.电源引脚</h3><p>VDD&#x2F;VSS：为片内集成的数字外设供电（8个）</p><p>VDDA&#x2F;VSSA：为片内集成的模拟外设供电（2个）</p><p>VBAT：为片内的实时时钟供电，确保断电后能正常工作（1个）</p><p>VCAP_1：用于电源滤波（1个）</p><h3 id="2-复位及启动模式引脚"><a href="#2-复位及启动模式引脚" class="headerlink" title="2.复位及启动模式引脚"></a>2.复位及启动模式引脚</h3><p>NRST（复位引脚）：复位电平为低电平有效（1个）</p><p>BOOT0，PB2（BOOT1）：启动引脚，两个引脚决定芯片的启动模式（2个）</p><h3 id="3-时钟引脚"><a href="#3-时钟引脚" class="headerlink" title="3.时钟引脚"></a>3.时钟引脚</h3><p>OSC32_IN,OSC32_OUT：接入外部低速时钟（2个）</p><p>OSC_IN,OSC_OUT：接入外部高速时钟（2个）</p><h3 id="4-仿真调试引脚"><a href="#4-仿真调试引脚" class="headerlink" title="4.仿真调试引脚"></a>4.仿真调试引脚</h3><p>PA13,PA14：作为SWD的穿行调试接口（2个）</p><h3 id="5-通用数字I-O引脚"><a href="#5-通用数字I-O引脚" class="headerlink" title="5.通用数字I&#x2F;O引脚]"></a>5.通用数字I&#x2F;O引脚]</h3><p>除了作为数字I&#x2F;O意外，还作为片内外设的功能引脚</p><h1 id="2-Nucleo开发版最小系统设计"><a href="#2-Nucleo开发版最小系统设计" class="headerlink" title="2.Nucleo开发版最小系统设计"></a>2.Nucleo开发版最小系统设计</h1><p>微控制器最小系统的定义：</p><p>狭义：仅包括电源电路，时钟电路，复位电路，调试电路及主控芯片电路</p><p>广义：还包括基本的人机接口电路，如指示灯，按键，蜂鸣器，数码管及串口通信等电路</p><p>以狭义为例：</p><h2 id="1-电源电路：为整个电路系统提供所需的供电电压"><a href="#1-电源电路：为整个电路系统提供所需的供电电压" class="headerlink" title="1.电源电路：为整个电路系统提供所需的供电电压"></a>1.电源电路：为整个电路系统提供所需的供电电压</h2><p>两种供电方式：外部和USB</p><p>VIN：外部供电端口（可以输入7V到12V的直流电压），经过电压转换芯片（LD1117S50TR）转换出5V的电源电压</p><p>E5V：外部供电端口（可以输入5V的直流电压）</p><p>+3V3：外部供电端口（可以输入3.3V的直流电压）</p><p><strong>注：三个外部电源输入均引出到外扩接口</strong></p><p>U5V：USB供电（可以输入5V的直流电压）</p><p>最后通过JP5进行电源输入的选择，当2-3短接（外部供电），当2-1短接（USB供电），默认USB供电</p><p>LD3用于指示电路板已经正常上电，再通过电压转换芯片（LD39050PU33R）转换出3.3V的供电电压（VDD），最后提供给目标MCU及外围电路</p><h2 id="2-时钟电路：为MCU提供所需的时钟信号"><a href="#2-时钟电路：为MCU提供所需的时钟信号" class="headerlink" title="2.时钟电路：为MCU提供所需的时钟信号"></a>2.时钟电路：为MCU提供所需的时钟信号</h2><p><strong>时钟源：</strong></p><p><strong>LSI：内部低速时钟，由片内RC振荡器提供，默认频率32KHz</strong></p><p><strong>HSI：内部高速时钟，由片内RC振荡器提供，默认频率16MHz</strong></p><p><strong>HSE：外部高速时钟，通过OSC_IN和OSC_OUT引脚接入晶振实现，频率范围（4MHz-26MHz）,也可以直接接入外部时钟信号，频率范围（1MHz-50MHz）</strong></p><p><strong>LSE：外部低速时钟，通过OSC32_IN和OSC32_OUT引脚接入32.768KHz的晶振实现</strong></p><p>时钟电路的两种设计方法：震荡模式&#x2F;旁路模式（一般使用震荡模式）</p><p>外部高速时钟HSE：通过晶振X3和两个匹配电容C33和C34（阻值为20p）接入到OSC_IN和OSC_OUT引脚（默认没有焊接晶振X3），实际使用的时钟来自于ST-Link仿真器所提供的8MHz时钟，因此实际上Nucleo开发板上时钟电路选择的是旁路模式</p><p>外部低速时钟LSE：通过晶振X2和两个匹配电容C31和C32（阻值为4.3p）接入到OSC32_IN和OSC32_OUT引脚。</p><p>要想使用震荡模式（添加外部晶振）：</p><p>1.断开焊桥SB16，SB50，SB54和SB55</p><p>2.焊接8MHz石英晶体X3</p><p>3.焊接2个20pF电容C33和C34</p><p>4.焊接2个0欧电阻R35和R37或者用焊锡短接</p><h2 id="3-调试电路：位MCU提供程序下载和调试的接口"><a href="#3-调试电路：位MCU提供程序下载和调试的接口" class="headerlink" title="3.调试电路：位MCU提供程序下载和调试的接口"></a>3.调试电路：位MCU提供程序下载和调试的接口</h2><p>两种调试接口（JTAG调试接口&#x2F;SWD调试接口）</p><p><img src="https://cui1225.oss-cn-beijing.aliyuncs.com/img/f36b90ad-198f-4e18-9861-a4fde7d34daf.png" alt="f36b90ad-198f-4e18-9861-a4fde7d34daf"></p><h2 id="4-复位电路：为MCU提供统一的初始状态"><a href="#4-复位电路：为MCU提供统一的初始状态" class="headerlink" title="4.复位电路：为MCU提供统一的初始状态"></a>4.复位电路：为MCU提供统一的初始状态</h2><p>采用了传统的阻容复位电路（上电复位和手动复位）由MCU的复位引脚NRST内部的上拉电阻和电容C14g构成，阻容复位提供上电复位的功能，复位按键B2提供手动复位的功能，当B2按下（NRST与地连接）用于系统复位，在工程实际中，一般使用专用复位芯片（SP706S）来构成复位电路，可以提供标准的复位脉冲，还提供了电压监控</p><h2 id="5-主控芯片"><a href="#5-主控芯片" class="headerlink" title="5.主控芯片"></a>5.主控芯片</h2><p><img src="https://cui1225.oss-cn-beijing.aliyuncs.com/img/67bdcbc5-0ad9-40ae-9af6-25ded7f9ed50.png" alt="67bdcbc5-0ad9-40ae-9af6-25ded7f9ed50"></p><p><img src="https://cui1225.oss-cn-beijing.aliyuncs.com/img/41a787f1-edaf-4a95-9ebd-3f2ea9d44f3b.png" alt="41a787f1-edaf-4a95-9ebd-3f2ea9d44f3b"></p><p><img src="https://cui1225.oss-cn-beijing.aliyuncs.com/img/66a1d9a2-ae4d-4019-a265-726c027f689e.png" alt="66a1d9a2-ae4d-4019-a265-726c027f689e"></p><table><thead><tr><th align="center">BOOT0</th><th align="center">BOOT1</th><th align="center">启动模式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">X</td><td align="center">用户闪存存储器</td><td align="center">从MCU片内Flash启动，常用启动方式</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">系统存储器</td><td align="center">从系统存储器启动，主要用于串口下载（ISP模式）</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">SRAM启动</td><td align="center">从MCU片内SRAM启动，主要用于代码调试</td></tr></tbody></table><p>（0，X）用户闪存存储器是最常用的启动模式</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发命令行程序</title>
      <link href="/2024/04/10/Java%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
      <url>/2024/04/10/Java%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一-输入输出"><a href="#一-输入输出" class="headerlink" title="一. 输入输出"></a>一. 输入输出</h1><ul><li>输入的作用，就是由使用者告诉程序要操作的数据<ul><li>例如，我要通过饿了么订餐，你得告诉程序你要吃什么，送货地址是什么吧</li></ul></li><li>输出的作用，就是由程序向使用者展现执行的结果<ul><li>还是订餐的例子，程序向你展示骑手接单没有，送到哪里了</li></ul></li><li>将来输入输出来源会有多种，比如 app，网页，终端程序等等</li></ul><h2 id="1-System-out"><a href="#1-System-out" class="headerlink" title="1. System.out"></a>1. System.out</h2><p>之前已经介绍过【标准输出】：System.out</p><p>打开 jshell 用一下，回忆下对象和方法使用格式<br>    对象.方法(参数);</p><p>套用一下，对象是 System.out，方法是 println，参数是 “你好”<br>    jshell&gt; System.out.println(“你好”);<br>    你好</p><p>小技巧</p><ul><li>jshell 中用 <code>Tab</code> 键可以提示对象有哪些方法</li><li>jshell 中省略 <code>;</code> 也不会报错</li></ul><h2 id="2-System-in"><a href="#2-System-in" class="headerlink" title="2. System.in"></a>2. System.in</h2><p>再来看看输入，对象是 System.in，方法叫 read，没有参数<br>    jshell&gt; System.in.read();</p><p>运行后，可以看到光标一闪一闪，表示正在等待用户的输入，这时输入小 a<br>    jshell&gt; System.in.read();<br>    a<br>    $1 &#x3D;&#x3D;&gt; 97</p><ul><li><p>会显示 97，称之为返回值，代表 read() 读入的结果</p><ul><li>因为计算机中所有符号，都是用数字表示，参看下表</li></ul></li><li><p>前面的 $1 是一个【变量】，将来它就代表 97，也就是刚才输入的小 a</p></li><li><p>【变量】可以反复被使用</p></li></ul><table><thead><tr><th>\</th><th>00</th><th>01</th><th>02</th><th>03</th><th>04</th><th>05</th><th>06</th><th>07</th><th>08</th><th>09</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>0000</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td></tr><tr><td>0016</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td><td>无</td></tr><tr><td>0032</td><td></td><td>!</td><td>“</td><td>#</td><td>$</td><td>%</td><td>&amp;</td><td>‘</td><td>(</td><td>)</td><td>*</td><td>+</td><td>,</td><td>-</td><td>.</td><td>&#x2F;</td></tr><tr><td>0048</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>:</td><td>;</td><td>&lt;</td><td>&#x3D;</td><td>&gt;</td><td>?</td></tr><tr><td>0064</td><td>@</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td><td>I</td><td>J</td><td>K</td><td>L</td><td>M</td><td>N</td><td>O</td></tr><tr><td>0080</td><td>P</td><td>Q</td><td>R</td><td>S</td><td>T</td><td>U</td><td>V</td><td>W</td><td>X</td><td>Y</td><td>Z</td><td>[</td><td>\</td><td>]</td><td>^</td><td>_</td></tr><tr><td>0096</td><td>&#96;</td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td><td>i</td><td>j</td><td>k</td><td>l</td><td>m</td><td>n</td><td>o</td></tr><tr><td>0112</td><td>p</td><td>q</td><td>r</td><td>s</td><td>t</td><td>u</td><td>v</td><td>w</td><td>x</td><td>y</td><td>z</td><td>{</td><td>\</td><td></td><td>}</td><td>~</td></tr></tbody></table><p>System.in 的缺点</p><ol><li>字符被转成的数字，不便人类阅读</li><li>只能输入一个字符</li></ol><h2 id="3-Scanner"><a href="#3-Scanner" class="headerlink" title="3. Scanner"></a>3. Scanner</h2><p>用 Scanner 改进，System.in 是 java 为我们提供好的对象，而 Scanner 需要我们自己创建，语法是<br>    jshell&gt; new Scanner(System.in);<br>    $2 &#x3D;&#x3D;&gt; java.util.Scanner…</p><p>将来这个 $2 就代表刚才的 Scanner 对象，我们称之为【变量】</p><p>Scanner 对象里面最常用的方法是 nextLine，用法如下<br>    jshell&gt; $2.nextLine();<br>    你好啊<br>    $3 &#x3D;&#x3D;&gt; “你好啊”</p><h2 id="4-变量名"><a href="#4-变量名" class="headerlink" title="4. 变量名"></a>4. 变量名</h2><p><code>$2</code>，<code>$3</code> 这样作为变量名虽然也可以，但如果用更有意义的名称来表示，更方便人类阅读、记忆。例如<br>    jshell&gt; var scanner &#x3D; new Scanner(System.in)<br>    scanner &#x3D;&#x3D;&gt; java.util.Scanner[delimiters&#x3D;\p{javaWhitespace}+] … \E][infinity string&#x3D;\Q∞\E]<br>    jshell&gt; var line &#x3D; scanner.nextLine()<br>    hello<br>    line &#x3D;&#x3D;&gt; “hello”</p><ul><li>scanner 就代指输入对象</li><li>line 就代指用 nextLine() 读取到的字符串值</li><li>var 是关键字，代表某种类型，具体有哪些类型后面再展开</li></ul><h2 id="5-关键字"><a href="#5-关键字" class="headerlink" title="5. 关键字"></a>5. 关键字</h2><p>变量取名时要注意两个规则，不能以数字开头，不能是关键字</p><p>什么是关键字呢？关键字就是 java 中有特殊意义的单词，例如见过的有 class，var，new 等等，如果用 idea 中可以通过特殊颜色强调哪些单词是关键字，可以看到这些蓝色的单词都属于关键字</p><p>至java 17 为止，共有 67 个关键字，参看这两份表格，这些关键字，都会在今后的课程中陆续学到</p><p></p><p></p><h1 id="二-类型、变量、运算符"><a href="#二-类型、变量、运算符" class="headerlink" title="二. 类型、变量、运算符"></a>二. 类型、变量、运算符</h1><h2 id="1-字符与字符串"><a href="#1-字符与字符串" class="headerlink" title="1. 字符与字符串"></a>1. 字符与字符串</h2><h3 id="字符值与字符串值"><a href="#字符值与字符串值" class="headerlink" title="字符值与字符串值"></a>字符值与字符串值</h3><p>像这样用双引号引起来的值，在 Java 里称为字符串，字符串顾名思义，由多个字符组成，单个字符用单引号表示，例如<br>    jshell&gt; ‘a’<br>    $4 &#x3D;&#x3D;&gt; ‘a’<br>    jshell&gt; “abc”<br>    $5 &#x3D;&#x3D;&gt; “abc”</p><ul><li>单引号里必须由一个字符</li><li>双引号里可以有零个、一个、多个字符</li></ul><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>比如我需要输出一个单引号字符值，<code>&#39;&#39;&#39;</code> 这样写行不行？本意是想表示中间的单引号，但遗憾的是java把前两个单引号当成了一对，把它当作了那个空字符了</p><p>怎么办呢</p><p>为了把真正的单引号跟语法的单引号区分开，需要给它加一个反斜杠标记，告诉java，我想表示真正的单引号，而不是语法中的单引号。试一下。<br>    jshell&gt; System.out.println(“&#39;“)<br>    ‘</p><p>这种结合了反斜杠的具有特殊含义的字符，称之为转义字符（Escape Character）</p><p>常见的有七个：<code>\&#39; \&quot; \\ \n \t \b \r</code> 刚才已经讲过单引号转义了</p><p>继续来看几个例子<br>    jshell&gt; System.out.println(“&quot;“) &#x2F;&#x2F; 双引号转义<br>    “<br>    jshell&gt; System.out.println(“\“) &#x2F;&#x2F; 反斜杠本身转义<br>    <br>    jshell&gt; System.out.println(“1\n2”) &#x2F;&#x2F; 换行<br>    1<br>    2</p><pre><code>jshell&gt; System.out.println(&quot;123\t4&quot;) // 缩进123     4jshell&gt; System.out.println(&quot;123\b4&quot;) // 退格124jshell&gt; System.out.println(&quot;123\r4&quot;) // 回车，退格是光标退一格，回车是退到头423</code></pre><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>最后再再来看看文本块，如果有一段文字内，其中需要有很多的转义字符，那么可读性会变得很差，例如<br>    jshell&gt; System.out.println(“床前&quot;明月&quot;光，\n疑是地上霜。”)</p><p>因此在 java 14 这个版本引入了文本块来进行改善。<br>    jshell&gt; System.out.println(“””<br>                               床前”明月”光，<br>                               疑是地上霜。”””)</p><p>文本块本质上还是属于字符串值，由一对 三个双引号作为起始和结束标记，中间如果想表示双引号、换行这两个特殊字符，无需再转义表示</p><ul><li>一个注意事项是 “”” 后需要换个行，不要紧接着写字符。</li></ul><h2 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h2><h3 id="何为类型"><a href="#何为类型" class="headerlink" title="何为类型"></a>何为类型</h3><p>现在让用户输入两个数，求得相加结果<br>    jshell&gt; scanner.nextLine()<br>    1<br>    $22 &#x3D;&#x3D;&gt; “1”<br>    jshell&gt; scanner.nextLine()<br>    2<br>    $23 &#x3D;&#x3D;&gt; “2”<br>    jshell&gt; $22 + $23<br>    $24 &#x3D;&#x3D;&gt; “12”</p><p>显然，这并不是我们想要的结果，它是输入的值当作了字符串，+ 号执行的是字符串连接操作，解决办法如下<br>    jshell&gt; scanner.nextInt()<br>    1<br>    $25 &#x3D;&#x3D;&gt; 1<br>    jshell&gt; scanner.nextInt()<br>    2<br>    $26 &#x3D;&#x3D;&gt; 2<br>    jshell&gt; $25 + $26<br>    $27 &#x3D;&#x3D;&gt; 3</p><p>nextLine() 和 nextInt() 返回的类型是不同的</p><ul><li>前者返回的是字符串，类型为 String，+ 表示两个字符串连接</li><li>后者返回的是整数，类型为 int，+ 表示两个整数相加</li></ul><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><table><thead><tr><th>类型名</th><th>说明</th><th>数字范围</th><th>类型后缀</th></tr></thead><tbody><tr><td>byte</td><td>整数类型，用1个字节表示</td><td>$[-2^7,2^7)$ 即 $[-128,128)$</td><td></td></tr><tr><td>short</td><td>整数类型，用2个字节表示</td><td>$[-2^{15},2^{15})$</td><td></td></tr><tr><td>int</td><td>整数类型，用4个字节表示</td><td>$[-2^{31},2^{31})$</td><td></td></tr><tr><td>long</td><td>整数类型，用8个字节表示</td><td>$[-2^{63},2^{63})$</td><td>L</td></tr><tr><td>float</td><td>浮点小数，用4个字节表示</td><td>$[-1.9999999 * 2^{127},1.9999999 * 2^{127}]$</td><td>F</td></tr><tr><td>double</td><td>浮点小数，用8个字节表示</td><td>$[-1.9999999 * 2^{1023},1.9999999 * 2^{1023}]$</td><td>D</td></tr></tbody></table><ul><li><p><code>[]</code> 包含等于，<code>()</code> 不包含等于</p></li><li><p>类型后缀</p><ul><li>不区分大小写，但建议用大写，因为小写的 L 与 1 容易混淆</li><li>尾符号 D 可以省略</li></ul></li><li><p>float 和 double 精度不同，即小数点后的位数</p><ul><li>float 的精度二进制是 23，换算成十进制是 6~7</li><li>double 的精度二进制是 52，换算成十进制是 15~16</li></ul></li></ul><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><table><thead><tr><th>类型名</th><th>说明</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>字符类型，配合单引号</td><td>$[0,2^{16})$ 即 $[0, 65536)$</td></tr><tr><td>String</td><td>字符串类型，配合双引号或文本块</td><td>-</td></tr></tbody></table><h2 id="3-变量与运算符"><a href="#3-变量与运算符" class="headerlink" title="3. 变量与运算符"></a>3. 变量与运算符</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量的定义格式为<br>    类型 变量名 &#x3D; 值;</p><ul><li>从语法可以看到，变量由类型和名称组成，类型决定了变量能存储的数据大小与数据格式，名字用来代表后面的值</li><li>这个语法其实咱们前面见过类似的，var scanner &#x3D; new Scanner(System.in)，这里 var 是类型，因为之前我们还没有学习具体有哪些类型，因此使用了 var 来代表某种类型，scanner是变量名，后面这一串就是值，也是 Scanner 对象</li></ul><p>&#x3D; 称之为赋值运算符，可以用来更新变量代表的值。</p><p>例如：<br>    int a &#x3D; 10</p><p>这行代码的意思是，定义了整型变量a，更新它的初始值为10</p><p>再来一句：<br>    a &#x3D; 20</p><p>这时候为啥不用写前面的类型了呢，因为变量定义只需一次，定义好之后变量就可以反复使用了，这行代码的意思是，将 a 所代表的值更新为 20</p><p>变量可以用来保存运算的结果，它自身也能参与运算</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><pre><code>int a = 5 + 3</code></pre><p>结果为 8<br>    int a &#x3D; 5 - 3</p><p>结果为 2<br>    int a &#x3D; 5 * 3</p><p>结果为 15<br>    int a &#x3D; 5 &#x2F; 3</p><p>结果为 1，整数除法有两个注意点</p><ul><li><p>整数除法，只会保留商，而小数部分会被舍弃，并不考虑四舍五入</p></li><li><p>除0是不合法的，会出错<br>  int a &#x3D; 5 % 3</p></li></ul><p>结果为 2</p><p>小数加减乘除与整数类似，只是小数除法可以保留小数点后的数字，而且可以除零，例如<br>    jshell&gt; 5.0 &#x2F; 3.0<br>    $40 &#x3D;&#x3D;&gt; 1.6666666666666667<br>    jshell&gt; 5.0 &#x2F; 0.0<br>    $41 &#x3D;&#x3D;&gt; Infinity</p><p>增强赋值运算符<br>    int a &#x3D; 20;<br>    a &#x3D; a + 10;</p><p>意思是，获取 a 的原有值 20，执行加 10 运算，将新的结果重新赋值给 a，a 代表的值被更新成了 30。可以用 +&#x3D; 增强赋值运算符达到类似的效果<br>    a +&#x3D; 10;</p><p>先不要看 &#x3D; 号，获取 a 的原有值 30，执行加 10 运算，运算的结果 40 赋值给 a<br>    a -&#x3D; 10;</p><p>先拿 a 的原有值 40 与后面的 10 做减法，再将结果 30 赋值给 a</p><p>自增自减运算符</p><p>两个特殊运算符 ++ 与 –</p><p>++ 是让变量自增1，– 是让变量自减1，举个例子<br>    int a &#x3D; 10;<br>    a++;</p><p>结果为 11，++ 和 – 既可以写在变量之前，也可以写在变量之后，这两种写法的区别，我们到高级篇再讲，目前暂不用去了解</p><h2 id="4-练习-房贷计算器"><a href="#4-练习-房贷计算器" class="headerlink" title="4. 练习 - 房贷计算器"></a>4. 练习 - 房贷计算器</h2><p>【等额本息还款】法计算房贷</p><blockquote><p>术语</p><ul><li><p>等额本息是指一种贷款的还款方式，是在还款期内，每月偿还同等数额的贷款（包括本金和利息）</p></li><li><p>每月偿还的贷款可以通过下述公式计算$p * r * (1 + r)^m &#x2F; ((1 + r)^m - 1)$</p><ul><li>p 为贷款本金 principal</li><li>r 为月利率 monthlyInterestRate</li><li>m 为还款月数 months</li></ul></li></ul></blockquote><p>公式中这些都是什么意思呢</p><p>例如：贷款 200 万元 ，对应公式中的 p，200 万就是贷款本金，年利率 6%，月利率 mr 就是 6% &#x2F; 12 &#x3D; 0.5%，假设 10 年还清，这时还款月数就是 360 个月。套入公式计算即可得到每月还多少钱</p><p>要完成这个计算，有一点没学过的是求这里的 1+ mr 的 m 次方，计算它需要用一个求幂方法，这个方法是 jdk 核心类库中 Math 这个类提供的，Math的字面意思是数学，Math 类中提供了很多与数学计算相关的方法，如果你以后有这方面需求，就找它。</p><h3 id="Math-pow"><a href="#Math-pow" class="headerlink" title="Math.pow()"></a>Math.pow()</h3><p>pow 是 static 方法，语法为 <code>类名.方法名(参数值)</code>，它需要两个参数，参数1是底数，参数2是指数<br>    jshell&gt; Math.pow(2.0, 1)<br>    $42 &#x3D;&#x3D;&gt; 2.0<br>    jshell&gt; Math.pow(2.0, 2)<br>    $43 &#x3D;&#x3D;&gt; 4.0<br>    jshell&gt; Math.pow(2.0, 3)<br>    $44 &#x3D;&#x3D;&gt; 8.0</p><p>解答</p><p>打开 idea，编写 Calculator 类<br>    public class Calculator {<br>        public static void main(String[] args) {<br>            Scanner scanner &#x3D; new Scanner(System.in);<br>            System.out.println(“请输入贷款本金 p”);<br>            double p &#x3D; scanner.nextDouble();<br>            System.out.println(“请输入年利率 r%”);<br>            double yr &#x3D; scanner.nextDouble();<br>            double mr &#x3D; yr &#x2F; 100.0 &#x2F; 12.0;</p><pre><code>        System.out.println(&quot;请输入贷款月数 m&quot;);        int m = scanner.nextInt();        System.out.println(p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1));    &#125;&#125;</code></pre><h3 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h3><p>对结果的数字进行格式化，让它以货币的格式来显示</p><p>需要借助核心类库中一个 NumberFormat 对象，字面意思是数字格式化，使用它的 getCurrencyInstance 方法来获取一个货币格式化对象，再使用它的 format 方法把 double 小数格式化为货币格式，格式化时也会保留两位小数</p><p>例子<br>    System.out.println(NumberFormat.getCurrencyInstance(Locale.CHINA).format(1000000.00));   System.out.println(NumberFormat.getCurrencyInstance(Locale.US).format(1000000.00));<br>    System.out.println(NumberFormat.getCurrencyInstance(Locale.GERMANY).format(1000000.00));<br>    System.out.println(NumberFormat.getCurrencyInstance(Locale.KOREA).format(1000000.00));</p><p>输出<br>    ¥1,000,000.00<br>    $1,000,000.00<br>    1.000.000,00 €<br>    ₩1,000,000</p><p>如果 Locale 省略不写，默认为中国</p><p>房贷计算器可以改写为<br>    double payment &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1);       System.out.println(NumberFormat.getCurrencyInstance().format(payment));</p><h3 id="查阅-Javadoc"><a href="#查阅-Javadoc" class="headerlink" title="查阅 Javadoc"></a>查阅 Javadoc</h3><p>练习做完了，大家学到了什么呢？</p><p>有同学说，学会怎么算每月还款了，是吗？并不是，通过这个例子，要认识到 java 核心类库能帮我们解决很多问题，比如说求幂运算，比如说数字格式化，包括之前学过的 Scanner 都是核心类库提供的功能，这就提醒我们，要解决某个编程问题之前，要先想一想核心类库有没有这方面的功能，如果有拿来用就行了，不必自己重新实现某项功能的代码，我们是站在巨人的肩膀上进行编程的。</p><p>当然，同学们并不是一开始就知道核心类库都提供了哪些功能，因此，这就需要我们不断去熟悉核心类库，熟悉它都有哪些类，哪些方法，比较重要的功能都在后续的课程中都会陆续介绍到，当然呢，同学们也不能总等着老师来喂知识，也可以自己查阅 javadoc 来扩展自己的知识面</p><p>javadoc 就是 java documentation 的缩写，我们下载的 jdk 中已经自带了，无需额外再下载。那怎么查阅 javadoc 呢，如果大家用的是 idea，那么可以通过一些快捷键来查阅java文档</p><ul><li><p>比如想看看类的文档，这时先按 Ctrl + N 查找类，假设我想看 Math 类的文档，输入要查阅的类名 Math，回车，可以跳转到这个类</p></li><li><p>接下来我想看看方法的文档怎么办呢，按一下 ctrl + f12，列出当前类的所有方法，绿色表示可以使用方法，橙色带锁的，表示是该类一种特殊的私有方法，不能直接使用。找感兴趣的方法时，如果你懂一些英文单词，那么会有一定优势，例如你想找一个平方根方法，它对应的英文是 sqrt，这时敲入这几个字母，就会定位到方法，同样可以用翻译查看该方法的功能</p></li><li><p>可以查到它的作用：返回一个数的平方根，这是方法名，查看后面括号内可以得知，需要一个参数，代表要求平方根的那个数字，是一个double 小数，方法名称前还有个 double 表示它的结果类型也是一个 double 小数</p></li><li><p>Math 中的方法大部分都是 static 方法，也就是配合类名使用的方法，之前也说过，用法为 类名.方法名(参数)</p></li></ul><p>在平时写代码时，如果忘记了某个方法的作用，可以光标定位到该方法，按 Ctrl + Q 进行查阅，效果是类似的</p><h1 id="三-条件语句"><a href="#三-条件语句" class="headerlink" title="三. 条件语句"></a>三. 条件语句</h1><p>编程时有一种重要的语句叫做条件语句，之前我们学过的都属于顺序语句，也就是从上至下，依次要执行每一行代码。</p><p>但是有的情况下，我们并不希望所有代码都执行，而是希望满足条件的代码才执行</p><p>例如：要对用户输入数据的合法性进行检查：</p><ul><li>贷款本金必须大于0</li><li>贷款月数范围在 1 ~ 360 之间</li><li>年利率范围在 1% ~ 36% 之间</li></ul><p>如果你输入的值连这些条件都不满足，有必要去计算每月还款金额吗？</p><p>这种情况下，就要用到条件语句了，它的语法格式为<br>    if(条件) {<br>        &#x2F;&#x2F; 条件为 true 执行这里<br>    } else {<br>        &#x2F;&#x2F; 条件为 false 执行这里<br>    }</p><p>什么意思呢，if 本意是如果，如果条件成立，执行代码1，else 本意是否则，即条件不成立，执行代码2，其中 <code>else &#123; &#125;</code> 语句块不是必须的，可以省略</p><p>那么条件这部分怎么写呢？对于数字类型可以借助比较运算符的运算结果来充当条件，参考下面的表格，这种表格列出了所有比较运算符</p><table><thead><tr><th>比较运算符</th><th>含义</th><th></th></tr></thead><tbody><tr><td>a &#x3D;&#x3D; b</td><td>判断 a 与 b 是否相等</td><td></td></tr><tr><td>a &gt; b</td><td>判断 a 是否 &gt; b</td><td></td></tr><tr><td>a &gt;&#x3D; b</td><td>判断 a 是否 &gt;&#x3D; b</td><td></td></tr><tr><td>a &lt; b</td><td>判断 a 是否 &lt; b</td><td></td></tr><tr><td>a &lt;&#x3D; b</td><td>判断 a 是否 &lt;&#x3D; b</td><td></td></tr><tr><td>a !&#x3D; b</td><td>判断 a 与 b 是否不相等</td><td></td></tr></tbody></table><h2 id="1-boolean-类型"><a href="#1-boolean-类型" class="headerlink" title="1. boolean 类型"></a>1. boolean 类型</h2><p>判断的结果是布尔类型，可以充当条件，它的取值非真即假，真用 true 表示，假用 false 表示</p><h2 id="2-单条件"><a href="#2-单条件" class="headerlink" title="2. 单条件"></a>2. 单条件</h2><pre><code>jshell&gt; int a = 1000;a ==&gt; 1000jshell&gt; if(a &gt; 0)&#123;   ...&gt;     System.out.println(&quot;ok&quot;);   ...&gt; &#125; else &#123;   ...&gt;     System.out.println(&quot;必须&gt;0&quot;);   ...&gt; &#125;okjshell&gt; a = -1000;a ==&gt; -1000jshell&gt; if(a &gt; 0)&#123;   ...&gt;     System.out.println(&quot;ok&quot;);   ...&gt; &#125; else &#123;   ...&gt;     System.out.println(&quot;必须&gt;0&quot;);   ...&gt; &#125;必须&gt;0</code></pre><p>房贷计算器改写如下<br>    public static void main(String[] args) {<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        System.out.println(“请输入贷款本金 p”);<br>        double p &#x3D; scanner.nextDouble();<br>        if(p &gt; 0) {<br>            System.out.println(“请输入年利率 r%”);<br>            double yr &#x3D; scanner.nextDouble();<br>            double mr &#x3D; yr &#x2F; 100.0 &#x2F; 12.0;<br>            System.out.println(“请输入贷款月数 m”);<br>            int m &#x3D; scanner.nextInt();</p><pre><code>        double payment = p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);        System.out.println(NumberFormat.getCurrencyInstance().format(payment));    &#125; else &#123;        System.out.println(&quot;贷款金额必须大于0&quot;);    &#125;&#125;</code></pre><h2 id="3-多条件"><a href="#3-多条件" class="headerlink" title="3. 多条件"></a>3. 多条件</h2><p>刚才我们在判断贷款本金的时候，只需要有一个大于 0 的条件就可以了，但是接下来我们要去检查年利率的时候，他是在一个范围之间，这就必须有两个条件，一个条件呢是要让年利率大于等于 1%，第二个条件呢，是让上年利率必须小于等于 36%，而且呢这两个条件你必须同时成立</p><p>多个条件可以用逻辑运算符连接</p><table><thead><tr><th>逻辑运算符</th><th>含义</th><th></th></tr></thead><tbody><tr><td>条件1 &amp;&amp; 条件2</td><td>&amp;&amp; 意思是并且，两个条件必须同时成立，结果为 true</td><td></td></tr><tr><td>条件1 \</td><td>\</td><td>条件2</td></tr><tr><td>! 条件</td><td>! 意思是取反</td><td></td></tr></tbody></table><p>举例<br>    jshell&gt; int b &#x3D; 120;<br>    b &#x3D;&#x3D;&gt; 120<br>    jshell&gt; if(b &gt;&#x3D; 1 &amp;&amp; b &lt;&#x3D; 360) {<br>       …&gt;     System.out.println(“ok”);<br>       …&gt; } else {<br>       …&gt;     System.out.println(“必须在1~360之间”);<br>       …&gt; }<br>    ok<br>    jshell&gt; b &#x3D; 0<br>    b &#x3D;&#x3D;&gt; 0</p><pre><code>jshell&gt; if(b &gt;= 1 &amp;&amp; b &lt;= 360) &#123;   ...&gt;     System.out.println(&quot;ok&quot;);   ...&gt; &#125; else &#123;   ...&gt;     System.out.println(&quot;必须在1~360之间&quot;);   ...&gt; &#125;必须在1~360之间jshell&gt; b = 361b ==&gt; 361jshell&gt; if(b &gt;= 1 &amp;&amp; b &lt;= 360) &#123;   ...&gt;     System.out.println(&quot;ok&quot;);   ...&gt; &#125; else &#123;   ...&gt;     System.out.println(&quot;必须在1~360之间&quot;);   ...&gt; &#125;必须在1~360之间</code></pre><p>房贷计算器改写如下<br>    public static void main(String[] args) {<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        System.out.println(“请输入贷款本金 p”);<br>        double p &#x3D; scanner.nextDouble();<br>        if(p &gt; 0.0) {<br>            System.out.println(“请输入年利率 r%”);<br>            double yr &#x3D; scanner.nextDouble();<br>            if (yr &gt;&#x3D; 1.0 &amp;&amp; yr &lt;&#x3D; 36.0) {<br>                double mr &#x3D; yr &#x2F; 100.0 &#x2F; 12.0;<br>                System.out.println(“请输入贷款月数 m”);<br>                int m &#x3D; scanner.nextInt();<br>                if (m &gt;&#x3D; 1 &amp;&amp; m &lt;&#x3D; 360) {<br>                    double payment &#x3D;<br>                        p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1);<br>                    System.out.println(NumberFormat.getCurrencyInstance()<br>                                       .format(payment));<br>                } else {<br>                    System.out.println(“贷款月数范围在 1 ~ 360 之间”);<br>                }<br>            } else {<br>                System.out.println(“年利率范围在 1% ~ 36% 之间”);<br>            }<br>        } else {<br>            System.out.println(“贷款金额必须大于0”);<br>        }<br>    }</p><h2 id="4-相反条件"><a href="#4-相反条件" class="headerlink" title="4. 相反条件"></a>4. 相反条件</h2><p>我们这段代码，逻辑上没错，但你会发现不容易阅读</p><p>多层 if 嵌套导致代码的可读性变得很差，一旦大家写代码时出现了两层以上的 if 语句，就要小心了。如何改进呢？</p><p>这里给同学们介绍一种方法：可以去除 else 提高代码可读性</p><p>比如，现在有两个分支，c 是一个条件，要么走分支1，要么走分支2，用下面的 if else 可以表示<br>    if(c) {<br>        &#x2F;&#x2F; 分支1<br>    } else {<br>        &#x2F;&#x2F; 分支2<br>    }</p><p>等价于<br>    if(!c) {<br>        &#x2F;&#x2F; 分支2<br>    } else {<br>        &#x2F;&#x2F; 分支1<br>    }</p><p>能不能不写 else 呢？假设进入了分支2，分支2的代码执行后，程序还会继续向下执行，导致分支1也被执行<br>    if(!c) {<br>        &#x2F;&#x2F; 分支2<br>    }<br>    &#x2F;&#x2F; 分支1</p><p>可以改写为下面的形式，这样就避免了 else 出现<br>    if(!c) {<br>        &#x2F;&#x2F; 分支2<br>        return;<br>    }<br>    &#x2F;&#x2F; 分支1</p><p>总结一下，以上代码的等价转换，有一句口诀：条件取反，if else 倒置，return 一加， else 可去</p><p>变换有一定的规律：</p><table><thead><tr><th>原条件</th><th>相反条件1</th><th>相反条件2</th></tr></thead><tbody><tr><td>p &gt; 0.0</td><td>!(p &gt; 0.0)</td><td>p &lt;&#x3D; 0.0</td></tr><tr><td>yr &gt;&#x3D; 1.0 &amp;&amp; yr &lt;&#x3D; 36.0</td><td>!(yr &gt;&#x3D; 1.0 &amp;&amp; yr &lt;&#x3D; 36.0)</td><td>yr &lt; 1.0 \</td></tr><tr><td>m &lt; 1 \</td><td>\</td><td>m &gt; 360</td></tr></tbody></table><ul><li><p>用逻辑与连接的两个条件，可以两个条件分别取反，然后&amp;&amp;变||</p><ul><li>年利率&gt;&#x3D;1.0 并且&lt;&#x3D;36.0 的相反条件是：年利率&lt;1.0 或者 年利率&gt;36.0</li></ul></li><li><p>用逻辑或连接的两个条件，可以两个条件分别取反，然后||变&amp;&amp;</p></li></ul><p>这种逻辑变换规律称之为反演规则，公式记不住没关系，简单的反演我们自己就能想出来，复杂的变换才用公式保证正确性</p><p>房贷计算器改写如下<br>    public static void main(String[] args) {<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        System.out.println(“请输入贷款本金 p”);<br>        double p &#x3D; scanner.nextDouble();<br>        if (p &lt;&#x3D; 0.0) {<br>            System.out.println(“贷款金额必须大于0”);<br>            return;<br>        }<br>        System.out.println(“请输入年利率 r%”);<br>        double yr &#x3D; scanner.nextDouble();<br>        if (yr &lt; 1.0 || yr &gt; 36.0) {<br>            System.out.println(“年利率范围在 1% ~ 36% 之间”);<br>            return;<br>        }<br>        double mr &#x3D; yr &#x2F; 100.0 &#x2F; 12.0;<br>        System.out.println(“请输入贷款月数 m”);<br>        int m &#x3D; scanner.nextInt();<br>        if (m &lt; 1 || m &gt; 360) {<br>            System.out.println(“贷款月数范围在 1 ~ 360 之间”);<br>            return;<br>        }<br>        double payment &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1);<br>        System.out.println(NumberFormat.getCurrencyInstance().format(payment));<br>    }</p><h1 id="四-循环语句"><a href="#四-循环语句" class="headerlink" title="四. 循环语句"></a>四. 循环语句</h1><h2 id="1-循环语句语法"><a href="#1-循环语句语法" class="headerlink" title="1. 循环语句语法"></a>1. 循环语句语法</h2><pre><code>for(初始化变量; 终止条件; 更新变量) &#123;    // 循环体代码&#125;</code></pre><ol><li>初始化部分仅执行一次</li><li>执行终止条件，如果为 true 继续循环，如果为 false 退出循环</li><li>执行循环体代码</li><li>执行迭代部分，从 2 开始执行</li></ol><p>例如<br>    for(int i &#x3D; 0; i &lt; 3; i++) {<br>        System.out.println(i);<br>    }</p><p>执行流程如下</p><ol><li>声明一个变量 i，初始值为 0，用来控制循环次数</li><li>判断 i &lt; 3，此时 i 取值是 0，条件为 true，继续循环</li><li>System.out.println(0)</li><li>i++，自增为 1</li><li>判断 i &lt; 3，此时 i 取值是 1，条件为 true，继续循环</li><li>System.out.println(1)</li><li>i++，自增为 2</li><li>判断 i &lt; 3，此时 i 取值是 2，条件为 true，继续循环</li><li>System.out.println(2)</li><li>i++，自增为 3</li><li>判断 i &lt; 3，此时 i 取值是 3，条件为 false，退出循环</li></ol><h2 id="2-变量的作用范围"><a href="#2-变量的作用范围" class="headerlink" title="2. 变量的作用范围"></a>2. 变量的作用范围</h2><p>上例中 i 的作用范围，仅在循环语句的 {} 内有效，现在要求求 1~100 的整数和，则需要把 sum 这个变量定义在 {} 外层<br>    int sum &#x3D; 0;<br>    for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) {<br>        sum +&#x3D; i;<br>    }<br>    System.out.println(sum);</p><p>这里能否这样写<br>    for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) {<br>        int sum &#x3D; 0;<br>        sum +&#x3D; i;<br>    }<br>    System.out.println(sum);</p><p>不行，变量有它们各自的作用范围，从变量的定义开始，找到包围它的，右 } 括号为止。</p><ul><li>在它上面用它</li><li>在右括号外用它</li></ul><h2 id="3-练习-贷款计算详情"><a href="#3-练习-贷款计算详情" class="headerlink" title="3. 练习 - 贷款计算详情"></a>3. 练习 - 贷款计算详情</h2><p>现在需要计算每月偿还的利息、偿还的本金、剩余的本金</p><p>例如，借款 1000 元，利息 100%，两月还清，根据公式计算出来每月还款 1333.33</p><table><thead><tr><th>月份</th><th>本月还款</th><th>偿还本金</th><th>偿还利息</th><th>剩余本金</th></tr></thead><tbody><tr><td>1</td><td>1333.33</td><td>333.33</td><td>1000.00</td><td>666.67</td></tr><tr><td>2</td><td>1333.33</td><td>666.67</td><td>666.67</td><td>0</td></tr><tr><td>总额</td><td>2666.67</td><td>1000.00</td><td>1666.67</td><td></td></tr></tbody></table><p>可以看到</p><ul><li>$偿还利息 &#x3D; 剩余本金 * 月利率$</li><li>$偿还本金 &#x3D; 每月还款 - 偿还利息$</li></ul><p>房贷计算器改写如下<br>    public static void main(String[] args) {<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        System.out.println(“请输入贷款本金 p”);<br>        double p &#x3D; scanner.nextDouble();<br>        if (p &lt;&#x3D; 0.0) {<br>            System.out.println(“贷款金额必须大于0”);<br>            return;<br>        }<br>        System.out.println(“请输入年利率 r%”);<br>        double yr &#x3D; scanner.nextDouble();<br>        if (yr &lt; 1.0 || yr &gt; 36.0) {<br>            System.out.println(“年利率范围在 1% ~ 36% 之间”);<br>            return;<br>        }<br>        double mr &#x3D; yr &#x2F; 100.0 &#x2F; 12.0;<br>        System.out.println(“请输入贷款月数 m”);<br>        int m &#x3D; scanner.nextInt();<br>        if (m &lt; 1 || m &gt; 360) {<br>            System.out.println(“贷款月数范围在 1 ~ 360 之间”);<br>            return;<br>        }<br>        double payment &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1);<br>        System.out.println(NumberFormat.getCurrencyInstance().format(payment));<br>        double totalInterest &#x3D; 0.0;                 &#x2F;&#x2F; 总利息<br>        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) {<br>            double interest &#x3D; p * mr;               &#x2F;&#x2F; 每月偿还利息<br>            double principal &#x3D; payment - interest;  &#x2F;&#x2F; 每月偿还本金<br>            p -&#x3D; principal;                         &#x2F;&#x2F; 剩余本金<br>            totalInterest +&#x3D; interest;<br>            System.out.print(i);<br>            System.out.print(“\t本月还款:” +<br>                             NumberFormat.getCurrencyInstance().format(payment));<br>            System.out.print(“\t偿还本金:” +<br>                             NumberFormat.getCurrencyInstance().format(principal));<br>            System.out.print(“\t偿还利息:” +<br>                             NumberFormat.getCurrencyInstance().format(interest));<br>            System.out.println(“\t剩余本金:” + NumberFormat.getCurrencyInstance().format(p));<br>        }<br>        System.out.print(“总还款额:” +<br>                         NumberFormat.getCurrencyInstance().format(payment * m));<br>        System.out.println(“\t总利息:” +<br>                           NumberFormat.getCurrencyInstance().format(totalInterest));<br>    }</p><h1 id="五-方法"><a href="#五-方法" class="headerlink" title="五. 方法"></a>五. 方法</h1><p>将来代码多了，全部写在 main 方法里，会显得非常凌乱，难于阅读。这节课的目标是使用方法来改写前面的代码。</p><h2 id="1-定义方法"><a href="#1-定义方法" class="headerlink" title="1. 定义方法"></a>1. 定义方法</h2><p>先来了解一下定义方法的语法<br>    [访问修饰符] [static] 返回结果类型 方法名([参数类型1 参数名1, 参数类型2 参数名2, …]) {<br>        &#x2F;&#x2F; 方法体<br>        return 返回结果<br>    }</p><ul><li>其中用 [] 的（[] 不是语法的一部分）是可选部分</li><li>访问修饰符先省略不写，后面再讲</li><li>static 这里先写上，这个前面提过，用 static 修饰的方法不属于对象</li><li>方法执行完毕后可能会有返回结果<ul><li>如果没有返回结果，返回值类型填写 void</li><li>如果有返回结果，填写实际的类型，例如<ul><li>返回整数，填写 int</li><li>返回小数，填写 double</li></ul></li></ul></li><li>方法名随便起，但应当做到望文生义</li><li>参数是方法执行时需要传入的数据，可以有零到多个，格式为【参数类型 参数名】，多个参数之间用逗号分隔</li><li>{} 内写方法的具体代码</li><li>最后 return 用来结束方法的运行，如果方法有返回结果，也需要配合 return 把结果传递给调用者</li></ul><p>例如，想计算一下两个整数的和<br>    class Test {<br>        static int add(int a, int b) {<br>            return a + b;<br>        }<br>    }</p><h2 id="2-调用方法"><a href="#2-调用方法" class="headerlink" title="2. 调用方法"></a>2. 调用方法</h2><p>回忆一下 Math.pow(2.0, 2) 就是一个由 java 提供好的 static 方法，它怎么用呢，Math 是类名，pow 是方法名，括号内是参数，对于我们自己写的 static 方法，用法是类似的：<br>    类名.方法名([参数值1, 参数值2, …])</p><p>即<br>    Test.add(100,200);</p><p>怎么拿到返回结果呢？<br>    int c &#x3D; Test.add(100,200);</p><p>如果是调用本类 static 方法，可以省略前面的类名</p><h2 id="3-方法的意义"><a href="#3-方法的意义" class="headerlink" title="3. 方法的意义"></a>3. 方法的意义</h2><p>学完了方法的定义、调用流程，再来看看方法的意义</p><p>方法的一个意义在于隐藏实现细节：</p><p>例如，对于前面例子中的【等额本息】方式计算房贷，如果没有方法，那就要求编程者必须非常清楚计算公式<br>    double payment &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1);</p><p>假设有一位资深程序员（例如你）提供了计算房贷方法，那么编程者就只需要知道：</p><p>计算等额本金还款，需要一个名字叫calculate的方法</p><p>它需要三个参数，… ，至于具体的计算过程，被隐藏在了方法内部<br>    double payment &#x3D; calculate(p, mr, m);</p><ul><li>p 贷款本金</li><li>mr 月利率</li><li>m 贷款月数</li></ul><p>对于使用它的小白程序员来讲，无需了解它的实现细节，直接拿来用就可以了。小白程序员是站在你的肩膀上编程</p><p>方法的另一个意义在于减少重复代码、提高代码的可维护性：</p><p>对比以下代码，第一段是没用方法，如果有一处写错了，所有重复的地方都得修改<br>    double p1 &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1);<br>    double p2 &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1);<br>    double p3 &#x3D; p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1);</p><p>用了方法，万一写错，只需要一个地方的代码需要修改<br>    static double calculate(double p, double mr, int m) {<br>        return p * mr * Math.pow((1 + mr), m) &#x2F; (Math.pow((1 + mr), m) - 1);<br>    }</p><h2 id="4-练习-贷款计算-方法改写"><a href="#4-练习-贷款计算-方法改写" class="headerlink" title="4. 练习 - 贷款计算 - 方法改写"></a>4. 练习 - 贷款计算 - 方法改写</h2><pre><code>public class Calculator3 &#123;    public static void main(String[] args) &#123;        double p = inputAndCheckP();        double mr = inputAndCheckMr();        int m = inputAndCheckM();        double payment = Calculator3.calculate(p, mr, m);        printDetails(p, mr, m, payment);    &#125;    static double inputAndCheckP() &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入本金&quot;);        double p = scanner.nextDouble();        if(p &lt;= 0) &#123;//            System.out.println(&quot;贷款金额必须 &gt; 0&quot;);            // throw new 异常类型(&quot;提示信息&quot;)            throw new IllegalArgumentException(&quot;贷款金额必须 &gt; 0&quot;);        &#125;        return p;    &#125;    static double inputAndCheckMr() &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入年利率&quot;);        double yr = scanner.nextDouble();        if(yr &lt; 1.0 || yr &gt; 36.0) &#123;            throw new IllegalArgumentException(&quot;年利率必须是 1 ~ 36&quot;);        &#125;        return yr / 12.0 / 100;    &#125;    static int inputAndCheckM() &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入还款月数&quot;);        int m = scanner.nextInt();        if(m &lt; 1 || m &gt; 360) &#123;            throw new IllegalArgumentException(&quot;贷款月数必须是 1 ~ 360&quot;);        &#125;        return m;    &#125;    static void printDetails(double p, double mr, int m, double payment) &#123;        for (int i = 0; i &lt; m; i++) &#123;            double payInterest = p * mr;                    // 偿还利息            double payPrincipal = payment - payInterest;    // 偿还本金            p -= payPrincipal;                              // 剩余本金            System.out.print (&quot;月份:&quot; + (i + 1));            System.out.print(&quot;\t本月还款:&quot; + NumberFormat.getCurrencyInstance().format(payment));            System.out.print(&quot;\t偿还本金:&quot; + NumberFormat.getCurrencyInstance().format(payPrincipal));            System.out.print(&quot;\t偿还利息:&quot; + NumberFormat.getCurrencyInstance().format(payInterest));            System.out.println(&quot;\t剩余本金:&quot; + NumberFormat.getCurrencyInstance().format(p));        &#125;        System.out.println(&quot;总还款额:&quot; + NumberFormat.getCurrencyInstance().format(payment * m));    &#125;</code></pre><p>​<br>​        &#x2F;**<br>​         * 以等额本息方式计算每月还款金额<br>​         * @param p 本金<br>​         * @param mr 月利率<br>​         * @param m 还款月数<br>​         * @return 每月还款金额<br>​         *&#x2F;<br>​        static double calculate(double p, double mr, int m) {<br>​            double pow &#x3D; Math.pow(1 + mr, m);<br>​            return p * mr * pow &#x2F; (pow - 1);<br>​        }<br>​    }</p><h3 id="说明1"><a href="#说明1" class="headerlink" title="说明1"></a>说明1</h3><p>大家抽取方法时有一个原则，就是把一组完整功能，所对应的多行代码抽取为一个方法，这里我们把计算还款总额和计算还款详情，分别抽取了两个方法</p><ul><li>calculate</li><li>printDetails</li></ul><p>抽取时，要点如下</p><ul><li>方法名要见文知义</li><li>返回值不着急写，看看方法的外部需不需要用到这个方法内的变量<ul><li>需要，返回值定义为结果类型</li><li>不需要，返回值定义为 void</li></ul></li><li>参数也不着急写，看方法内缺哪些变量定义，以它们为方法参数</li></ul><h3 id="说明2"><a href="#说明2" class="headerlink" title="说明2"></a>说明2</h3><p>对于 calculate 这种比较重要的方法定义，最好给它加一个文档，你得告诉将来这个方法的使用者，怎么用这个方法，每个参数是什么意思。</p><p>先写斜杠两个星号的开始，不用着急写它的结束，直接一回车。idea 就会自动生成一段 javadoc 文档，你可以在这里介绍方法的作用</p><ul><li>在 @param 这里对每个参数进行说明</li><li>在 @return 这里对返回值进行说明。</li></ul><h3 id="说明3"><a href="#说明3" class="headerlink" title="说明3"></a>说明3</h3><p>如果在某些验证不通过，想让剩余代码不要运行，可以利用 throw 语法</p><ul><li>return 这种语法叫正常返回，也就是当方法调用后，代码还会继续运行</li><li>还有就是这种throw 语法，它称为异常返回，如果没有额外处理，代码从方法调用后就中断运行</li></ul><h1 id="六-package-与-jar"><a href="#六-package-与-jar" class="headerlink" title="六. package 与 jar"></a>六. package 与 jar</h1><h2 id="1-package"><a href="#1-package" class="headerlink" title="1. package"></a>1. package</h2><p>随着我们写的类越来越多，把他们都放在一块儿来管理，感觉比较的不规范，因此，我们要引入一个新的package语法，对源文件进行一个更好的管理。</p><p>其实这个package说白了就是Java中一种目录结构<br>    |- 包1<br>        |- 从属于包1 的类<br>    |- 包2<br>        |- 从属于包2 的类</p><p>语法：<br>    package 包名; &#x2F;&#x2F; 告诉下面的类从属于此包<br>    class 类 {<br>    }</p><p>包的命名一般都是域名的倒置，如</p><ul><li>baidu.com 域名的倒置就是 com.baidu</li><li>bilibilicom 域名的倒置就是 com.bilibili</li></ul><h2 id="2-import"><a href="#2-import" class="headerlink" title="2. import"></a>2. import</h2><p>与 package 关系非常密切的一个语法：import，如果你的类想使用另外一个类，而两个类不同包，这时就必须用 import，把另一个类导入进来才能使用<br>    package com.itheima.a;<br>    import java.util.Scanner;<br>    class Calulator {<br>        public static void main(String[] args) {<br>            &#x2F;&#x2F; 要用到 Scanner, 这时就用用到上面的 import 语句<br>        }<br>    }</p><ul><li>有一种特殊情况不需要 import 导入，即 java.lang 包下的类使用时，都不需要 import</li></ul><h2 id="3-jar"><a href="#3-jar" class="headerlink" title="3. jar"></a>3. jar</h2><p>代码写完了，我们最终要发布成品吧，那是把源文件直接给使用者吗？显然不是吧。最终交给 jvm 运行的是 class 类文件，我们会把这多个 class 类文件打成一个压缩包，交付给用户。</p><p>用 idea 可以方便地打包</p><p>步骤1：创建工件（artifact）</p><p></p><p>步骤2：构建工件</p><p></p><p>步骤3：运行 jar 包，需要客户电脑上安装好 jdk<br>    java -jar jar包文件名</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2024/04/10/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/04/10/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Java-简介"><a href="#一-Java-简介" class="headerlink" title="一. Java 简介"></a>一. Java 简介</h1><p>Java 是第一大编程语言和开发平台。它有助于企业降低成本、缩短开发周期、推动创新以及改善应用服务。如今，Java 仍是企业和开发人员的首选开发平台，全球有数百万开发人员运行超过 51 亿台 Java 虚拟机。</p><h2 id="1-JVM"><a href="#1-JVM" class="headerlink" title="1. JVM"></a>1. JVM</h2><ul><li>它是 Java Virtual Machine 也就是 Java 虚拟机的缩写，它的职责是解释执行Java代码。我们写好的 Java 代码，并不能被直接运行，而是需要交给 JVM 来解释执行</li><li>很多公司都提供了 JVM 实现，最为知名的是 Oracle 提供的 JVM 实现</li></ul><h2 id="2-JRE"><a href="#2-JRE" class="headerlink" title="2. JRE"></a>2. JRE</h2><ul><li>JRE呢，是 Java runtime environment 的缩写，含义是 Java 的运行环境。Java 代码编写好了以后，不仅是需要 JVM 对它来进行解释，而且也需要一些基础功能的配合，这些基础功能呢，称之为核心类库（Core libraries），JVM 和核心类库加在一起，就构成了 JRE 这个运行环境</li></ul><h2 id="3-JDK"><a href="#3-JDK" class="headerlink" title="3. JDK"></a>3. JDK</h2><ul><li>JDK是 Java development kit 的缩写，含义是 Java 的开发环境。如果你不仅仅要运行 Java 程序，还想开发新的 Java 程序，那还需要借助一些开发工具，JRE 跟开发工具合在一起，就构成了JDK</li></ul><p></p><p>通过刚才的讲解，我们了解到 JVM、JRE、JDK 之间是一个包含的关系：</p><ul><li>JDK 功能最全，包含了 JRE 和开发工具</li><li>其次是 JRE，包含了 JVM + 核心类库</li><li>最后是 JVM，负责解释执行我们的 Java 代码</li></ul><p>因此，对于后面的学习，我们只需要下载安装 JDK 就可以进行 Java 开发了</p><blockquote><p>从 Java 11 这个版本开始，不再单独提供 JRE</p><ul><li>In this release, the JRE or Server JRE is no longer offered. Only the JDK is offered. Users can use <code>jlink</code> to create smaller custom runtimes.</li></ul></blockquote><h1 id="二-安装-JDK"><a href="#二-安装-JDK" class="headerlink" title="二. 安装 JDK"></a>二. 安装 JDK</h1><h2 id="1-下载和安装"><a href="#1-下载和安装" class="headerlink" title="1. 下载和安装"></a>1. 下载和安装</h2><p>这里介绍 Windows 10 平台下 Oracle 的 JDK 安装</p><p>入口在哪儿？访问 oracle 官网 <a href="https://www.oracle.com/index.html">Oracle | Cloud Applications and Cloud Platform</a></p><p></p><p>点击 Java 后进入下面的页面</p><p></p><p>下载页面让我们选择版本，这里选择 Java 17，因为它是长期支持版（LTS）</p><ul><li>18 虽然看着新，但实际上到 2022.9 就会被 19 取代</li><li>而 17 的支持会到 2024 年</li></ul><p>接下来选择平台，这里选择 Windows，其它平台下 JDK 的安装，请关注我们后续的视频</p><p>Windows 有三个版本，第一个是解压版，后两个是安装版。初学者我建议下载解压版（有助于理解 java 程序的查找过程）</p><p></p><p>下载完毕后，解压到一个<strong>没有中文和空格</strong>的目录即可</p><h2 id="2-配置-Path"><a href="#2-配置-Path" class="headerlink" title="2. 配置 Path"></a>2. 配置 Path</h2><p>你可以选择一个喜欢的目录，我的解压目录是 d 盘根目录下，如图所示</p><ul><li>其中 bin 目录下包含的就是它所带的一些开发和运行工具</li><li>像 Javac.exe 还有 Java.exe 都是较为重要的，后面都会用到</li></ul><p></p><p>验证安装是否成功：按快捷键 <code>Win + r</code>，输入命令提示符程序名称 <code>cmd</code></p><p></p><p>出现命令提示符窗口，输入 <code>java -version</code><br>    C:\Users\Lenovo&gt;java<br>    ‘java’ 不是内部或外部命令，也不是可运行的程序<br>    或批处理文件。</p><p>这是因为 cmd 程序并不知道 java 的安装位置，因此没有找到它</p><ul><li><p>可以输入它的全路径来找到它</p><ul><li>比如，我的 java 解压到了 D:\jdk-17.0.3.1 这个目录，这时全路径就是 D:\jdk-17.0.3.1\bin\java</li><li>但显然这么做比较麻烦</li></ul></li><li><p>更好的方式是配置 Path【环境变量】</p></li></ul><p>按快捷键 <code>win</code> 搜索【此电脑】，出现下面的界面</p><p></p><p>点击【属性】，找到【高级系统设置】</p><p></p><p>按下图箭头顺序找到<strong>新建</strong>，把刚才 jdk 的解压目录 + bin 补充填入，我这里是 D:\jdk-17.0.3.1\bin，全部确定。</p><p></p><blockquote><p>Path 环境变量的作用：</p><ul><li>Path 环境变量中记录的是程序执行时的搜索路径</li><li>cmd 执行一个程序时，即使未给出完整路径，也会在 Path 环境变量列出的目录下依次查找该程序<ul><li>找到了，则执行</li><li>都找不到，才报错</li></ul></li><li>因此对刚才的问题，只需将 java 程序的所在目录补充进 Path 环境变量</li></ul></blockquote><p>环境变量改动后，原有的 cmd 窗口是不受影响的，要想生效<strong>必须</strong>打开一个新的 cmd 窗口，输入 <code>java -version</code>，如果出现类似于下面的输出，表示成功<br>    C:\Users\Lenovo&gt;java -version<br>    java version “17.0.2” 2022-01-18 LTS<br>    Java(TM) SE Runtime Environment (build 17.0.2+8-LTS-86)<br>    Java HotSpot(TM) 64-Bit Server VM (build 17.0.2+8-LTS-86, mixed mode, sharing)</p><h2 id="3-配置-JAVA-HOME（选讲）"><a href="#3-配置-JAVA-HOME（选讲）" class="headerlink" title="3. 配置 JAVA_HOME（选讲）"></a>3. 配置 JAVA_HOME（选讲）</h2><p>网上的一些教程，都会让大家配置另一个叫做 JAVA_HOME 的环境变量，代表的是 JDK 的安装根目录。</p><ul><li>其实这个环境变量你可以不配，对于后续学习几乎没有影响</li><li>例外情况是，有的 java 程序，例如后面学到的 Tomcat 在启动时，会用到 JAVA_HOME 环境变量，但这属于个别现象，等我们学到它时再解决不迟</li><li>还有一个不配 JAVA_HOME 的理由：如果将来有不同的应用运行需要版本的 JDK，这时还不如不配全局 JAVA_HOME，让每个程序在启动脚本里指定自己需要的 JAVA_HOME</li></ul><p>出于知识的完整性，我们演示一下如何配置 JAVA_HOME，还是找到环境变量的配置窗口，在系统环境变量处点击新建，输入变量名和变量值，JAVA_HOME 名称是固定的，注意全大写，值是 JDK 的安装根目录，我这里是 D:\jdk-17.0.3.1</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>配完之后，发现 PATH 环境变量中的 D:\jdk-17.0.3.1\bin 与 JAVA_HOME 中的 D:\jdk-17.0.3.1 有一部分重复了，这样的问题是如果将来切换 jdk 版本，如果改了一处，忘记改另一处，就会造成不一致。</p><p>可以把 PATH 的取值修改为 %JAVA_HOME%\bin，其中 %JAVA_HOME% 代表引用 JAVA_HOME 环境变量的值，这样以后改动时，只需要改 JAVA_HOME 这一处就可以了</p><h1 id="三-入门案例"><a href="#三-入门案例" class="headerlink" title="三. 入门案例"></a>三. 入门案例</h1><p>这节课我们来学习 Java 的第一个入门程序，Hello world，目标是<strong>命令</strong> jvm，在程序窗口输出一行问候语。</p><h2 id="1-第一行代码"><a href="#1-第一行代码" class="headerlink" title="1. 第一行代码"></a>1. 第一行代码</h2><h3 id="1-jshell"><a href="#1-jshell" class="headerlink" title="1) jshell"></a>1) jshell</h3><p>首先用到的是一个名为 jshell 的开发工具，打开命令提示符 cmd，输入 jshell<br>    PS D:&gt; jshell<br>    |  欢迎使用 JShell – 版本 17.0.2<br>    |  要大致了解该版本, 请键入: &#x2F;help intro<br>    jshell&gt;</p><p>可以看到【jshell&gt;】后的光标在不断闪烁，表示可以继续在【jshell&gt;】后键入命令或代码</p><p>常见命令</p><ul><li>&#x2F;help 帮助信息</li><li>&#x2F;exit 退出 jshell</li></ul><p>第一行代码来了：输入 <code>System.out.println(&quot;Hello, world&quot;)</code>，要注意大小写和引号，查看效果</p><h3 id="2-代码解读"><a href="#2-代码解读" class="headerlink" title="2) 代码解读"></a>2) 代码解读</h3><p>下面来解释这行代码的意思</p><ul><li>它的整体效果是命令 JVM，给我在在程序窗口输出一行话，话的内容是：<code>Hello, world</code></li></ul><p>再来把代码拆解，看看每一部分的意思</p><ul><li><p>先要说明的是，咱们这个程序窗口内有两个较为抽象的组成部分，输出和输入</p><ul><li><p>其中输出的专业叫法是【标准输出】，用来将运算结果展现给用户，代码里就对应着 System.out</p></li><li><p>另一个是【标准输入】，用来接受用户输入的数据，代码里用 System.in 表示，后面再讲</p></li><li><p>System.out 、System.in 代表的这种计算机中的虚拟物体，以后统称之为【对象】</p></li><li><p>System.out 这个对象是 java 为我们提前准备好的</p></li><li><p>以后还有一些对象是需要我们自己创建的，后面会逐渐讲到</p></li></ul></li></ul><p>但是光是拿到 System.out 对象，它并不会显示 Hello, world，我们必须给它下命令，也就是调用对象的功能</p><ul><li>println() 代表的是 System.out 中的一种功能，以后称之为【方法】<ul><li>方法的特征是在使用时会带有一对 ()</li><li>不同的方法作用不同，println 方法的作用是将 () 内的内容展现到程序窗口并换行，System.out 对象还有 print 方法，区别是不换行输出内容</li><li>前面的点，表示一种从属关系<ul><li>即 println() 方法从属于 System.out 对象，print 方法也从属于 System.out 对象</li><li>从属关系决定了对象能否使用此方法，像 System.in 与 println 方法之间没有这种从属关系，就意味着 System.in 对象无法使用此 println 方法</li><li>想知道对象和哪些方法之间有从属关系，后面会给大家讲解怎么查，目前了解这些足够了</li></ul></li></ul></li><li>() 里面的 <code>&quot;hello, world&quot;</code> 叫做方法参数，你可以替换它为其它问候语<ul><li>不同的方法需要的参数个数及格式也有所不同，刚才我们用的这个 println 方法只接收了一个参数，以后大家可能见到不同个数和格式的参数，这些后面都会详细讲解</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从这行代码中学习了什么呀，要命令计算机执行功能，可以借助【对象】、【方法】和【参数】来完成</p><ul><li><p>刚才的例子中谁是对象？</p><ul><li>System.out</li></ul></li><li><p>它代表什么？</p><ul><li>标准输出</li></ul></li><li><p>谁是方法？</p><ul><li>println 是方法</li></ul></li><li><p>它有什么作用？</p><ul><li>不同方法作用不同，println 将括号内内容，也就是参数输出到程序窗口</li><li>这其中参数比较自由，由我们提供，可以是 hello, world, 可以是你好，也可以是其它问候语</li></ul></li><li><p>对象和方法是 java 提供的（当然以后我们也可以自己创建对象，定义新的方法，此乃后话）</p></li></ul><p>至此为止，这行代码的含义讲解完毕</p><h3 id="3-为何要分成对象与方法"><a href="#3-为何要分成对象与方法" class="headerlink" title="3) 为何要分成对象与方法"></a>3) 为何要分成对象与方法</h3><p>有同学问：Java的设计者搞个输出都这么麻烦，还分成对象和方法俩概念，把它们合为一个概念不是更简单吗？你看</p><ul><li>对象用来表示被操作的物体，是名词</li><li>方法用来告知让这个物体执行什么动作，是动词</li></ul><p>这种划分更符合现实世界中对事物的认知，例如，你叫住【皮卡丘】，皮卡丘就是待操作的对象，这时候他还不知道要做什么。好，你命令他【趴下】，这个趴下就是方法，是皮卡丘要执行的动作，你再命令他【吃饭】，这个吃饭是另一个方法。可以看到，现实世界都可以这么划分，那么把计算机中的虚拟物体抽象成对象和方法，当然也是顺理成章啦，这符合人类对事物的认知。</p><p>因此，不要怕麻烦，以后在 java 世界编写的代码，绝大多数都是这种对象+方法的形式，这称之为<strong>面向对象编程</strong>，今天我们还不会正式讲解面向对象编程，但同学们要建立起对象、方法的概念</p><h2 id="2-第一份源码"><a href="#2-第一份源码" class="headerlink" title="2. 第一份源码"></a>2. 第一份源码</h2><p>jshell 执行过的代码，在 jshell 退出后下次再想用，就不方便调出来了，正式的代码都会保存在类文件中，类文件的后缀是 .java，也称为 java 源代码</p><h3 id="1-源码结构"><a href="#1-源码结构" class="headerlink" title="1) 源码结构"></a>1) 源码结构</h3><p>源码结构如下，一份源码中可以包含多个类，每个类中又可以包含多个方法，方法内再包含语句代码<br>    class A {<br>        方法1() {<br>            &#x2F;&#x2F; 语句代码<br>        }<br>        方法2() {<br>            &#x2F;&#x2F; 语句代码<br>        }<br>        入口方法() {<br>            &#x2F;&#x2F; 语句代码<br>        }<br>    }<br>    class B {</p><pre><code>&#125;</code></pre><p>这里我们关注其中一个特殊方法：入口方法。</p><p>入口方法的格式是固定的：<br>    public static void main(String[] args) {<br>    }</p><p>以后我们就称它为 main 方法</p><ul><li>main 并不从属于任何对象（由 static 修饰）</li><li>main 方法内就可以书写之前学过的那行代码 System.out.println(“Hello, world”)</li><li>要注意与之前 jshell 中一点区别是，这里的每行代码以分号结束</li></ul><p>刚才给大家介绍了源代码的结构</p><ul><li>源代码中可以包含多个 class 类，每个类中再去套方法，方法内再去套代码，当我们把这些写好之后，能不能交给 JVM 来执行呢？</li><li>还不行，因为JVM不理解源码，需要通过 javac 开发工具把源代码编译成 class 字节码文件（这种字节码JVM可以理解）字节码文件的特点是后缀以 .class 结尾</li><li>最后再通过 java 工具可以将 class 字节码加载至 JVM，JVM 将字节码解释翻译为机器码，最终就可以由 CPU 执行啦。</li></ul><h3 id="2-编写-java-源代码"><a href="#2-编写-java-源代码" class="headerlink" title="2) 编写 java 源代码"></a>2) 编写 java 源代码</h3><p>进入 <code>d:</code> 盘</p><ul><li>目的是为了找到一个合适存储 java 源代码的位置，也可以是其他位置，总之方便你找到它<br>  C:\Users\Lenovo&gt;d:<br>  D:&gt;</li></ul><p>运行记事本程序，notepad 是记事本程序名称<br>    D:&gt;notepad</p><p>会打开如下窗口</p><p></p><p>输入如下代码<br>    class Hello {<br>        public static void main(String[] args) {<br>            System.out.println(“hello, world”);<br>        }<br>    }</p><ul><li><code>&quot;&quot;</code> 内的 hello, world 是我们自由书写，可以是英文、汉字</li><li><code>class</code> 后的 Hello 称之为【类名】，一般是英文单词</li><li>其余代码要与例子中的【完全一致】，并严格区分大小写</li></ul><p>保存文件，选择 <code>文件-&gt;保存</code> 或按它对应的快捷键 <code>Ctrl+S</code></p><p></p><ul><li>类名与最后的文件名请保持一致，保存为文件名以 <code>.java</code> 结尾</li><li>保存文件时，确保也存储于 <code>d:</code> 盘，方便待会找到它</li><li>编码位置也要注意，可能会影响到汉字的输出，后面会讲</li></ul><h3 id="3-编译-java-源代码"><a href="#3-编译-java-源代码" class="headerlink" title="3) 编译 java 源代码"></a>3) 编译 java 源代码</h3><p>关闭记事本程序，回到命令提示符程序，输入下面命令<br>    D:&gt;javac Hello.java</p><ul><li><p><code>javac</code> 用来把一个 <code>*.java</code> 文件编译成 <code>*.class</code> 文件</p></li><li><p><code>*.class</code> 就是前面提到的 class 字节码</p></li></ul><p>本例中，生成的字节码文件为 <code>Hello.class</code>，可以用 <code>dir</code> 命令查阅如下</p><p></p><h3 id="4-运行-class-字节码"><a href="#4-运行-class-字节码" class="headerlink" title="4) 运行 class 字节码"></a>4) 运行 class 字节码</h3><p>输入下面命令<br>    D:&gt;java Hello<br>    hello, world</p><ul><li><code>java</code> 命令用来把 Hello.class 加载到 JVM 并执行它</li></ul><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h2><h3 id="中文输出乱码"><a href="#中文输出乱码" class="headerlink" title="中文输出乱码"></a>中文输出乱码</h3><p>有的同学编写代码时用了中文<br>    class Hello {<br>        public static void main(String[] args) {<br>            System.out.println(“你好”);<br>        }<br>    }</p><p>编译、执行后输出为<br>    浣犲ソ</p><blockquote><p>发音：huan chai so</p></blockquote><p>原因在于，保存 Hello.java 文件时，选择了 UTF-8 编码，而 javac 编译时采用的是操作系统默认编码 GBK，只要两边编码不一致，就会发生上述的【乱码】问题</p><h4 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h4><p>保存文件时，选择编码为 ANSI（对于记事本程序 ANSI 其实就是 GBK）</p><p></p><h4 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h4><p>文件保存时，编码仍然是 UTF-8 不变，编译时改用下面的命令明确告诉编译器，编译时别用默认的 GBK，改用 UTF-8<br>    D:&gt;javac -encoding utf-8 Hello.java</p><h3 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h3><p>有的同学在执行 javac 时会遇到各种各样的问题，例如<br>    D:&gt;javac -encoding utf-8 Hello.java<br>    Hello.java:3: 错误: 非法字符: ‘\uff1b’<br>            System.out.println(“你好”)；<br>                                             ^<br>    1 个错误</p><p>遇到这种错误不用怕</p><ul><li>其中 <code>Hello.java:3</code> 意思是说，Hello.java 中第 3 行出现错误，这样就可以定位错误位置</li><li>接下来它又提示了具体错误原因：<code>错误: 非法字符: &#39;\uff1b&#39;</code>，本例中是因为输入了中文分号 <code>；</code>，java 语法要求语句结束符号是英文分号 <code>;</code></li><li>这些错误原因需要慢慢积累，见的多了就知道该怎么解决了</li></ul><h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h2><p>注释就是对程序代码的一个说明，比如：</p><ul><li>将来写的代码多了，你记性又没那么好，怕忘记某些代码的含义，这时候可以给它加一个注释</li><li>或是某些代码比较重要、特殊，这时也可以加一个注释进行说明</li></ul><p>强调一点，注释只是对代码的说明，只影响代码阅读，不影响代码的功能。</p><p>注释的格式分成了单行注释，多行注释，还有文档注释三种。</p><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>写在被注释代码的上方或右方，格式为<br>    &#x2F;&#x2F; 注释内容</p><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>如果注释内容比较长，都写在一行影响阅读，这时候就用多行注释，格式为<br>    &#x2F;*<br>        注释内容<br>        注释内容<br>    *&#x2F;</p><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>文档注释我们后面讲方法时再详细来讲吧，那现在呢，你只要了解它的格式：格式为：<br>    &#x2F;**<br>        注释内容<br>    *&#x2F;</p><h2 id="5-思考-为何需要字节码"><a href="#5-思考-为何需要字节码" class="headerlink" title="5. 思考-为何需要字节码"></a>5. 思考-为何需要字节码</h2><p>咱们先回忆一下 Java 程序的开发以及运行的流程</p><ul><li>首先得编写一个Java的源文件，源文件编写好了就能交给CPU来执行吗？</li><li>还不行啊，他得经过一个编译的步骤，也就是用那个javac程序把它编译成字节码文件</li><li>这个字节码文件呢，再经过一个叫 java 程序加载到 jvm 虚拟机，</li><li>jvm 虚拟机其实还做了一件很重要的事，就是把字节码文件给解释成机器码</li><li>机器码就是最为底层的代码了，CPU就可以识别和运行它</li></ul><p>所以整个流程是先把源文件变成字节码，再把字节码变成机器码，最终由CPU执行。</p><p>那这里大家可以思考这么一个问题，源代码，最终要变成机器码，是不是才能被CPU执行，那为什么我们不直接把Java 源码翻译成机器代码，而是多出了字节码这么一个中间环节呢？</p><h3 id="C-的翻译过程"><a href="#C-的翻译过程" class="headerlink" title="C++ 的翻译过程"></a>C++ 的翻译过程</h3><p>要解释清楚这个问题啊，我们就必须介绍一点历史。在Java语言发明之前呢，有一个比较流行的编程语言叫做c++语言，这个c++语言它就没有中间的环节，可以把源文件直接他翻译成最终的机器码。有同学说这不挺好？但是呢有这么一个问题：不同平台下的这个机器码是不通用的。</p><p>举个例子，在windows平台下编写好了c++源代码，可以把它经编译器编译为windows平台的机器码，但是这个机器码呢，只能用在windows平台。想拿到Linux平台下用，用不了。必须在 Linux 平台下，重新编译成Linux机器码。看看这样的缺点</p><ol><li>项目规模大了，源码编译也挺耗时间，在 windows 下编译一遍比如用了 20 分钟，测试通过了，将来要部署到 Linux 平台，又得编译一遍，再花 20 分钟… 时间都花在编译上了</li><li>程序员还得熟悉两个平台，做不到开发与部署环境相分离</li></ol><p>说完了这是c++程序需要多次编译缺点，那咱们再来看看 Java 是怎么解决这个问题的。</p><p></p><h3 id="Java-的翻译过程"><a href="#Java-的翻译过程" class="headerlink" title="Java 的翻译过程"></a>Java 的翻译过程</h3><p>Java做的就是加入了字节码这个中间环节，不管是在Linux下的编译还是在windows下的编译，生成的字节码是所有平台都通用的，你在windows平台生成的字节码在Linux平台一样用，反之亦然。可以看到</p><ol><li>编译只需要一次，编译时间被节省了</li><li>程序员只需要工作在自己熟悉的平台上就可以了，做到了开发与部署环境的分离</li></ol><p>这就是 java 所宣称的 write once run anywhere，编写一次，到处运行。</p><p>字节码虽然带来了这样一些便利，但大家思考一下，有什么问题吗？</p><p>对啦，问题就是字节码不是最终的机器码</p><ul><li>需要在每个平台上安装 jvm 虚拟机，负责把字节码解释为机器码</li><li>另外因为引入了把字节码解释为机器码的步骤，性能上会有一定损失，当然 jvm 为了保证性能，内部会做很多优化，这等我们讲到 jvm 时，会有更深入的认识</li></ul><p></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过初步对比 c++ 和 java 的不同编译策略，我们学习到一个词 trade-off，权衡。</p><ul><li>c++ 直接编译生成机器码，性能无与伦比，但一旦改变平台，会带来额外的编译成本</li><li>java 编译生成字节码，减少编译成本，增强灵活性，但性能不可避免受到影响，需要再通过其它方面补救</li></ul><p>以后大家如果进入到程序设计的领域，就会明白，所谓设计更多的是在各个方面做出权衡，没有最佳，只有最适合。</p><h1 id="四-IDE-工具"><a href="#四-IDE-工具" class="headerlink" title="四. IDE 工具"></a>四. IDE 工具</h1><p>俗话说，工欲善其事，必先利其器，要准备好开发工具，才能提高开发效率。如果像开始那样，用记事本编写 java 代码，不仅慢，而且很容易出错。</p><p>首先来介绍 IDE 工具，IDE 即 Integrated Development Environment 集成开发环境，能够提供给开发者更好的编码、编译、测试环境</p><h2 id="1-常见-IDE-工具"><a href="#1-常见-IDE-工具" class="headerlink" title="1. 常见 IDE 工具"></a>1. 常见 IDE 工具</h2><h3 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h3><p>老牌的 IDE 工具 Eclipse，有需要的同学可以根据下图下载尝试（<a href="https://www.eclipse.org/downloads/">Eclipse Downloads | The Eclipse Foundation</a>）</p><p></p><p>它的特点是</p><ul><li>完全免费</li><li>功能够用</li></ul><h3 id="Vscode"><a href="#Vscode" class="headerlink" title="Vscode"></a>Vscode</h3><p>以上两个工具属于<strong>重量级</strong>的 IDE 工具，如果想追求轻量级的工具，推荐使用 Visual Studio Code</p><p></p><p>它的特点有</p><ul><li>完全免费</li><li>更为轻量，占用磁盘空间比 eclipse 和 idea 少很多，前面两个工具属于重量级 ide 工具</li><li>系出名门，微软开发</li><li>插件丰富，通过插件几乎可以支持所有语言</li></ul><p>最后要介绍的一个 IDE 工具叫 Intellij IDEA，号称是最智能的 java 开发工具</p><h3 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h3><p>新流行的 IDE 工具 IntelliJ IDEA，推荐大家用它（<a href="https://www.jetbrains.com/zh-cn/idea/download/#section=windows">下载 IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE</a>）</p><p></p><p>它有三个版本</p><ul><li>Ultimate（最终版），功能最强，按年收费，价格不菲</li><li>Community（社区版），功能够用</li><li>如果你是在校学生，可以申请教育版<ul><li><a href="https://www.jianshu.com/p/fc56eadc7faf">通过教育邮箱免费申请IntelliJ IDE全家桶教程 - 简书 (jianshu.com)</a></li></ul></li></ul><p>特点</p><ul><li>更加智能</li></ul><p>因为我不想花钱，下载的是社区版，另外我选择的这种zip压缩格式的安装包，它使用起来更加简单，解压就能用</p><p>使用步骤</p><ul><li><p>选中下载好的压缩文件，解压，这里解压到 d：盘，注意保留后面的文件夹名称</p></li><li><p>进入d盘，进入解压目录中 bin子目录，找到一个名叫 idea64的程序双击，就可以运行了。</p></li></ul><h2 id="2-IntelliJ-IDEA-的配置及使用"><a href="#2-IntelliJ-IDEA-的配置及使用" class="headerlink" title="2. IntelliJ IDEA 的配置及使用"></a>2. IntelliJ IDEA 的配置及使用</h2><p>本教程使用 IntelliJ IDEA Community 2022.1（截至本教程开始开发时的最新版本）</p><h3 id="1-安装启动"><a href="#1-安装启动" class="headerlink" title="1) 安装启动"></a>1) 安装启动</h3><p>首次运行，会弹出下面窗口</p><p></p><p>意思是是否导入以前的设置（settings），因为我们是第一次安装，所以就选择默认的不导入设置</p><p>出现 splash 欢迎页</p><p></p><p>接下来进入主界面</p><p></p><p>在学习 idea 之前，先来做几项简单的设置，可以改改颜色主题（<code>Customize -&gt; Color theme</code>）</p><p></p><p>如果选择 <code>Sync with OS</code>，意思就是根据操作系统改变主题（白天亮、夜晚暗）</p><p></p><p>推荐安装翻译插件，方便阅读文档</p><p></p><h3 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2) 创建项目"></a>2) 创建项目</h3><p>创建新项目（Project）</p><p></p><p>在 IDEA 中【项目】和【模块】用来组织代码</p><ul><li>一个【项目】（Project）包含多个【模块】（Module）</li><li>一个【模块】（Module）包含多个【源文件】</li></ul><p>点击【新建项目】（New Project）后出现界面</p><p></p><p>其中</p><ul><li>存储位置中的 <code>~</code> 代表当前用户目录<ul><li>如我的 Windows 系统用户名为 <code>Lenovo</code>，则 <code>~</code> 对应目录为 <code>C:\Users\Lenovo</code></li><li>你也可以选择其它目录来存储【项目】位置，但注意目录中不建议有中文和空格</li></ul></li><li>语言这目前选择 <code>Java</code>，但要知道 JVM 还能运行其它几种语言：<code>Kotlin</code> 和 <code>Groovy</code></li><li>项目类型目前选择 <code>IntelliJ</code>，后续我们还会学习 <code>Maven</code> 和 <code>Gradle</code></li><li>如果安装了 JDK，会出现在这个下拉列表中</li><li>如果勾选了 <code>Add sample code</code>，则会生成一个简单的实例代码</li></ul><p>点击 <code>Create</code> 按钮后</p><p></p><p>首次进入项目会在右下角显示两个弹窗通知</p><p></p><p>建议都点一下</p><ul><li>前者能将 IntelliJ IDEA 的菜单中文化</li><li>后者能加速 IDEA 的使用速度</li></ul><p>因为前面勾选了实例代码，因此 idea 已经帮我们生成了一个简单的源文件，看一下，里面已经包含了类、main 方法和一段 hello world 代码。</p><h3 id="3-运行代码"><a href="#3-运行代码" class="headerlink" title="3) 运行代码"></a>3) 运行代码</h3><p></p><h1 id="五-实用工具"><a href="#五-实用工具" class="headerlink" title="五. 实用工具"></a>五. 实用工具</h1><h2 id="1-Ubuntu-子系统"><a href="#1-Ubuntu-子系统" class="headerlink" title="1. Ubuntu 子系统"></a>1. Ubuntu 子系统</h2><p>如果用 Windows 操作系统，推荐安装 Linux 子系统，即 WSL</p><ul><li>适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU&#x2F;Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销</li><li>官方安装文档：<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">安装 WSL | Microsoft Docs</a></li></ul><h3 id="1-安装-wsl-工具"><a href="#1-安装-wsl-工具" class="headerlink" title="1) 安装 wsl 工具"></a>1) 安装 wsl 工具</h3><pre><code>wsl --install</code></pre><h3 id="2-安装-Ubuntu-子系统"><a href="#2-安装-Ubuntu-子系统" class="headerlink" title="2) 安装 Ubuntu 子系统"></a>2) 安装 Ubuntu 子系统</h3><p>Ubuntu 是一种非常流行的 Linux 系统，打开微软应用商店</p><p></p><p>搜索 ubuntu</p><p></p><p>选一个版本安装（我用的是 18.04 LTS）</p><h3 id="3-运行-Ubuntu-子系统"><a href="#3-运行-Ubuntu-子系统" class="headerlink" title="3) 运行 Ubuntu 子系统"></a>3) 运行 Ubuntu 子系统</h3><p>安装完毕后，打开命令提示符，输入 wsl，即可进入 Ubuntu 子系统</p><p></p><p>这里就可以运行各种 Linux 下的 App 了，当然我们主要用的是命令行下的 App，图形界面的 App 不行</p><h2 id="2-终端工具"><a href="#2-终端工具" class="headerlink" title="2. 终端工具"></a>2. 终端工具</h2><p>命令提示符这个工具虽然能用，但是界面比较 low，这里给大家介绍一款终端工具：Fluent Terminal，也是在微软应用商店搜索</p><p></p><p>运行界面如下</p><p></p><p>好处是同时支持三种终端</p><ul><li>CMD（命令提示符）</li><li>PowerShell（Windows 下另一个终端工具）</li><li>WSL</li></ul><h2 id="3-截图工具"><a href="#3-截图工具" class="headerlink" title="3. 截图工具"></a>3. 截图工具</h2><p>做笔记的神器：Snipaste，也是在微软应用商店搜索</p><p></p><h2 id="4-笔记工具"><a href="#4-笔记工具" class="headerlink" title="4. 笔记工具"></a>4. 笔记工具</h2><p>笔记神器：Typora，1.0 版本后收费 89 元（可以找找低版本的），当然你也可以选择其它笔记工具</p><p></p><h2 id="5-思维导图工具"><a href="#5-思维导图工具" class="headerlink" title="5. 思维导图工具"></a>5. 思维导图工具</h2><p>推荐使用 Xmind 工具，免费的功能就够用</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>麻辣鱼</title>
      <link href="/2024/04/09/%E9%BA%BB%E8%BE%A3%E9%B1%BC/"/>
      <url>/2024/04/09/%E9%BA%BB%E8%BE%A3%E9%B1%BC/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

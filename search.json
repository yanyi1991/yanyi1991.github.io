[{"title":"2024-2025进程安排","url":"/2024/10/17/2024-2025进程安排/","content":"\n1.嵌入式仿真大赛（已经结束）\n\n2.软件学院第二届嵌入式系统设计竞赛-STM32智能宠物（正在进行）预计12月16日\n\n3.第十六届全国大学生数学竞赛（正在进行）预计11月9日\n\n4.第六届全国高校计算机能力挑战赛-python赛道（正在进行）预计11月17日\n\n5.英语四级（正在进行）预计12月14日\n\n6.蓝桥杯（明年）\n\n7.软考-软件设计师（明年）\n\n8.职业生涯规划大赛（正在进行）预计11月15校赛\n\n9.2024“冰雪杯”全国大学生外语能力大赛（正在进行）预计10月20日截止\n\n10.简历制作（正在进行）\n\n11.传智杯（正在进行）2024年11月\n\n12.华为ICT大赛-网络赛道（正在进行）\n\n13.互联网技能应用赛（12.3公布初赛排名）\n\n14.计算机学会学生会员（已入会）\n\n"},{"title":"绪论","url":"/2024/08/30/嵌入式系统原理及应用/","content":"\n\n\n## 1.嵌入式系统定义\n\n国际定义：根据（IEEE）将嵌入式系统定义为用于控制、监视或者辅助操作机器和设备的装置--主要根   据其应用对象方式定义\n\n国内定义：嵌入式系统是一个具有特殊功能和用途的计算机软硬件集合体--以系统的应用为中心，计算机技术为基础，软件与硬件的结合的专用计算机系统，此系统对功能、可靠性、成本、体积、功能具有严格要求\n\n## 2.嵌入式系统的特点\n\n专用型  实时性  生命周期长  小体积、低功耗  低成本  高稳定性  不可垄断性  \n\n## 3.嵌入式系统的应用\n\n消费电子  工业控制  网络应用  军用领域\n\n## 4.通用机与嵌入式系统区别\n\n### PC机系统：\n\n硬件：主机（CPU、主板、内存条、显卡）、显示器\n\n软件：相对独立（可安装/拆卸）\n\n操作系统：Windows Linux iOS\n\n### 嵌入式系统：\n\n硬件：MCU（将CPU、ROM-只读存储器、RAM-随机存储器、定时器、I/O接口集成在一片芯片上，形成芯片级计算机）、显示屏\n\n软件：集成/固化在芯片中，用户不能更改\n\n操作系统：Linux、winCE、Android\n\n### SOC（片上系统）\n\n以处理器为核心，加上外围功能（集成USB、ADC/DAC、以太网模块）的芯片，称为SOC片上系统\n\n### 处理器分类\n\n<u>嵌入式处理器</u>  \n\n是嵌入式系统的核心，是控制，辅助系统运行的硬件单元。目前可以分为：嵌入式微控制器（MCU），嵌入式微处理器（MPU），嵌入式DSP，嵌入式SoC（FPGA）\n\n<u>通用处理器</u>\n\n是以x86（x86文件）体系架构的被INTEL和AMD两家公司垄断，追求更快的运算速度、更大的数据吞吐量、有32、64位处理器等\n\n<u>嵌入式微控制器（MCU）</u>\n\n又称单片机，典型的MCU厂商有：ST（意法半导体）、TI（德州仪器）等\n\n<u>嵌入式微处理器（MPU）</u>\n\n由CPU演变而来，增强版的CPU，主要有：麒麟、A处理器、三星、高通等\n\n<u>嵌入式DSP</u>\n\n 主要专门用于信号处理方面，为了追求高执行效率，不适合运行操作系统，核心代码使用汇编\n\n<u>嵌入式SoC（FPGA）</u>\n\n可编程逻辑技术把整个系统放到一块硅片上，称作SOC，如Altera公司的FPGA 芯片、 Xilinx公司的FPGA芯片\n\n<u>ARM处理器</u>\n\nARM处理器占据了低功耗、低成本和高性能的嵌入式系统应用的大部分领域，特别是在移动市场，ARM处理器基本处于垄断地位，当前的智能手机的处理器基本都是各公司购买的ARM处理器内核开发出来的。\n\nCortex系列处理器：ARM公司在经典处理器**ARM11**以后的产品都改用**Cortex**命名，并分成A、R和M三类。\n\n### 存储系统\n\n<u>随机存取存储器（RAM）</u>\n\n 存储单元的内容可按需随意取出或存入，读写速度很快，且速度与存储单元的位置无关。RAM在断电时将丢失其存储内容，RAM主要用于存储短时间使用的程序。\n\n<u>静态随机存取存储器（Static Random Access Memory，SRAM）</u>\n\n<u>动态随机存取存储器（Dynamic Random Access Memory，DRAM）</u>\n\n<u>同步动态随机存储器（Synchronous Dynamic Random Access Memory，SDRAM）</u>\n\n<u>只读存储器（ROM）</u>\n\n 只读存储器中的数据可以在掉电后不丢失，ROM主要用于存储程序和一些数据（常量、系数等），存储在其中的数据只能读不能改；同时还存在一种需要使用特定的方法擦除和烧录数据的ROM，及电可擦除可编程ROM（EEPROM）\n\n<u>闪存存储器（FLASH）</u>\n\n闪存存储器是电可擦除的ROM，在使用上与EEPROM类似。但是二者的寻址方法不同，存储单元的结构也不同，Flash存储器的电路结构较简单，同样容量占芯片面积较小，成本比EEPROM低。常见固态硬盘和优盘都是闪存存储器。\n\n**嵌入式软件开发主要有两种方式**\n\n直接在芯片上进行应用开发   在芯片上运行操作系统\n\n嵌入式系统软件结构一般包含3个层面：**设备驱动层**、**OS层**、**应用层**\n\n嵌入式操作系统可以分为<u>嵌入式非实时操作系统</u>和<u>嵌入式实时操作系统</u>（**RTOS**）\n\n### 嵌入式系统的发展历程\n\n单片机时代（1970年代末）\n\n微控制器时代（1980年代）\n\n嵌入式操作系统时代（1990年代）\n\n嵌入式处理器时代（2000年代至今）","tags":["硬件","嵌入式"],"categories":["嵌入式·第一章"]},{"title":"Servlet","url":"/2024/06/18/实验七-Servlet/","content":"\n# 实验任务一\n\n```java\nGetParameterTest.java\n```\n\n```java\nimport java.io.*;  \nimport javax.servlet.ServletConfig;  \nimport javax.servlet.annotation.WebServlet;  \nimport javax.servlet.http.HttpServlet;  \nimport javax.servlet.http.HttpServletRequest;  \nimport javax.servlet.http.HttpServletResponse;  \n\n@WebServlet(name = \"GetParameterTest\", value = \"/GetParameterTest\")  \npublic class GetParameterTest extends HttpServlet {  \n    @Override  \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {  \n        response.setContentType(\"text/html;charset=utf-8\");  \n        PrintWriter out = response.getWriter();  \n        ServletConfig config = this.getServletConfig();  \n        String author = config.getInitParameter(\"author\");  \n        String school = config.getInitParameter(\"school\");  \n        String name = config.getInitParameter(\"Servlet名\");  \n        out.println(\"school：\"+school+\"<br>\");  \n        out.println(\"author：\"+author+\"<br>\");  \n        out.println(\"Servlet名：\"+name+\"<br>\");  \n    }  \n    @Override  \n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException { \n    }\n}\n```\n\n```java\nweb.xml\n```\n\n```xml\n<servlet>\n    <servlet-name>GetParameterTest</servlet-name>\n    <servlet-class>MyServlet.GetParameterTest</servlet-class>\n    <init-param>\n        <param-name>author</param-name>\n        <param-value>陈彩华</param-value>\n    </init-param>\n    <init-param>\n        <param-name>school</param-name>\n        <param-value>湖南广播电视大学</param-value>\n    </init-param>\n    <init-param>\n        <param-name>Servlet名</param-name>\n        <param-value>GetParameterTest</param-value>\n    </init-param>\n</servlet>\n<servlet-mapping>\n    <servlet-name>GetParameterTest</servlet-name>\n    <url-pattern>/GetParameterTest</url-pattern>\n</servlet-mapping>\n```\n\n# 实验任务二\n\n```\nGetWebParameter.java\n```\n\n```java\nimport java.io.*;\nimport javax.servlet.ServletContext;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(name = \"GetWebParameter\", value = \"/GetWebParameter\")\npublic class GetWebParameter extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        PrintWriter out = response.getWriter();\n        ServletContext context = this.getServletContext();\n        out.println(\"Web项目的所有参数如下\"+\"<br>\");\n        out.println(\"first：\" + context.getInitParameter(\"first\") + \"<br>\");\n        out.println(\"second：\" + context.getInitParameter(\"second\"));\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n    }\n}\n```\n\n```xml\nweb.xml\n```\n\n```xml\n<context-param>\n    <param-name>first</param-name>\n    <param-value>这是第一个参数的值</param-value>\n</context-param>\n<context-param>\n    <param-name>second</param-name>\n    <param-value>这是第二个参数的值</param-value>\n</context-param>\n```\n\n# 实验任务三\n\n```java\nShareParameterA\n```\n\n```java\nimport java.io.*;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletContext;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(name = \"ShareParameterA\", value = \"/ShareParameterA\")\npublic class ShareParameterA extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        ServletConfig config = this.getServletConfig();\n        ServletContext context = this.getServletContext();\n        context.setAttribute(\"a1\",config.getInitParameter(\"a\"));\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n    }\n}\n```\n\n```java\nShareParameterB\n```\n\n```java\nimport java.io.*;\nimport javax.servlet.ServletContext;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(name = \"ShareParameterB\", value = \"/ShareParameterB\")\npublic class ShareParameterB extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        PrintWriter out = response.getWriter();\n        ServletContext context = this.getServletContext();\n        out.println(context.getAttribute(\"a1\"));\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n    }\n}\n```\n\n# 实验任务四\n\n```java\ndata.properties\n```\n\n```properties\naddress=ChangSha\nschool=HXX\n```\n\n```java\nGetResourceServlet\n```\n\n```java\nimport java.io.*;\nimport java.util.Properties;\nimport javax.servlet.ServletContext;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(name = \"GetResourceServlet\", value = \"/GetResourceServlet\")\npublic class GetResourceServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        PrintWriter out = response.getWriter();\n        ServletContext context=getServletContext();\n        String path=context.getRealPath(\"data.properties\");\n        FileInputStream fis=new FileInputStream(path);\n        Properties pros=new Properties();\n        pros.load(fis);\n        String address=pros.getProperty(\"address\");\n        String school=pros.getProperty(\"school\");\n        out.println(\"地址：\"+address+\"<br>\");\n        out.println(\"学校：\"+school);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n    }\n}\n```\n\n#### 注：这么详细的配置还看不懂的话，抓紧退学\n","tags":["Java","html","jsp"],"categories":["实验七"]},{"title":"过滤器","url":"/2024/05/29/实验八-过滤器/","content":"\n# 实验任务一\n\nMyServlet.java\n\n```java\nimport java.io.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(name = \"MyServlet\", value = \"/MyServlet\")\npublic class MyServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        PrintWriter out = response.getWriter();\n        out.println(\"Servlet程序!\"+\"<br>\");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n    }\n}\n```\n\nMyFilter.java\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n@WebFilter(\"\")\npublic class MyFilter implements Filter {\n\n    @Override\n    public void destroy() {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        PrintWriter out = response.getWriter();\n        out.println(\"Filter程序！\"+\"<br>\");\n    }\n\n    @Override\n    public void init(FilterConfig config) {\n\n    }\n}\n```\n\nweb.xml\n\n```java\n    <filter>\n        <filter-name>MyFilter</filter-name>\n        <filter-class>Experiment8.MyFilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>MyFilter</filter-name>\n        <url-pattern>/MyServlet</url-pattern>\n    </filter-mapping>\n```\n\n# 实验任务二\n\nfirst.jsp\n\n<body>\n\n```html\n<h1> 这是JSP页面 </h1>\n```\n\n</body>\n\nForwardServlet.java\n\n```java\nimport java.io.*;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(name = \"ForwardServlet\", value = \"/ForwardServlet\")\npublic class ForwardServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        request.getRequestDispatcher(\"Experiment8/first.jsp\").forward(request,response);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n    }\n}\n```\n\nForwardFilter.java\n\n```java\nimport java.io.PrintWriter;\n\n@javax.servlet.annotation.WebFilter(\"\")\npublic class ForwardFilter implements javax.servlet.Filter {\n\n    @Override\n    public void destroy() {\n\n    }\n\n    @Override\n    public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws javax.servlet.ServletException, java.io.IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        PrintWriter out = response.getWriter();\n        out.println(\"这是过滤器程序！\"+\"<br>\");\n    }\n\n    @Override\n    public void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException {\n\n    }\n}\n```\n\nweb.xml\n\n```java\n    <filter>\n        <filter-name>ForwardFilter</filter-name>\n        <filter-class>Experiment8.ForwardFilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>ForwardFilter</filter-name>\n        <url-pattern>/Experiment8/first.jsp</url-pattern>\n        <dispatcher>FORWARD</dispatcher>\n    </filter-mapping>\n```\n\n# 实验任务三\n\nFilter01.java\n\n```java\nimport java.io.PrintWriter;\n\n@javax.servlet.annotation.WebFilter(\"\")\npublic class Filter01 implements javax.servlet.Filter {\n\n    @Override\n    public void destroy() {\n\n    }\n\n    @Override\n    public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws javax.servlet.ServletException, java.io.IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        PrintWriter out = response.getWriter();\n        out.println(\"第一个过滤器之前！<br>\");\n        chain.doFilter(request, response);\n        out.println(\"第一个过滤器之后！<br>\");\n    }\n\n    @Override\n    public void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException {\n\n    }\n}\n```\n\nFilter02.java\n\n```java\nimport java.io.PrintWriter;\n\n@javax.servlet.annotation.WebFilter(\"\")\npublic class filter02 implements javax.servlet.Filter {\n\n    @Override\n    public void destroy() {\n\n    }\n\n    @Override\n    public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws javax.servlet.ServletException, java.io.IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        PrintWriter out = response.getWriter();\n        out.println(\"第二个过滤器之前！<br>\");\n        chain.doFilter(request, response);\n        out.println(\"第二个过滤器之后！<br>\");\n    }\n\n    @Override\n    public void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException {\n\n    }\n}\n```\n\nFilterChainServlet.java\n\n```java\nimport java.io.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(name = \"FilterChainServlet\", value = \"/FilterChainServlet\")\npublic class FilterChainServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        PrintWriter out = response.getWriter();\n        out.println(\"这是过滤器链拦截的Servlet！<br>\");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n    }\n}\n```\n\nweb.xml\n\n```java\n<filter>\n    <filter-name>Filter01</filter-name>\n    <filter-class>Experiment8.Filter01</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>Filter01</filter-name>\n    <url-pattern>/FilterChainServlet</url-pattern>\n</filter-mapping>\n\n<filter>\n    <filter-name>Filter02</filter-name>\n    <filter-class>Experiment8.filter02</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>Filter02</filter-name>\n    <url-pattern>/FilterChainServlet</url-pattern>\n</filter-mapping>\n```\n\n# 实验任务四\n\nfilterForm.jsp\n\n<body>\n\n```html\n<form action=\"DealWithServlet\" method=\"post\">\n    <label>\n        请输入学生信息的模糊资料：<input type=\"text\" name=\"information\">\n    </label><br>\n    <input type=\"submit\" value=\"查询\">\n</form> \n```\n\n</body>\n\nDealWithServlet.java\n\n```java\nimport java.io.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(name = \"DealWithServlet\", value = \"/Experiment8/DealWithServlet\")\npublic class DealWithServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String information = request.getParameter(\"information\");\n        PrintWriter out = response.getWriter();\n        out.println(\"学生姓名：\" + information);\n    }\n}\n```\n\nEncodingFilter.java\n\n```java\n@javax.servlet.annotation.WebFilter(\"\")\npublic class EncodingFilter implements javax.servlet.Filter {\n\n    @Override\n    public void destroy() {\n\n    }\n\n    @Override\n    public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws javax.servlet.ServletException, java.io.IOException {\n        request.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"text/html;charset=UTF-8\");\n        chain.doFilter(request, response);\n    }\n\n    @Override\n    public void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException {\n\n    }\n}\n```\n\nweb.xml\n\n```java\n<filter>\n    <filter-name>EncodingFilter</filter-name>\n    <filter-class>Experiment8.EncodingFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>EncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n","tags":["Java","html","jsp"],"categories":["实验八"]},{"title":"测试","url":"/2024/05/29/测试/","content":"\n---\n\n\n\n![](https://gitee.com/yanyi-2004/picbed/raw/master/img/202504131552928.jpeg)"},{"title":"stm32_Day2","url":"/2024/04/16/stm32-Day2/","content":"\n# Nucleo开发板外围电路设计\n\n## 1．指示灯电路（高电平/低电平驱动）\n\n高电平：指示灯的负极接地，指示灯的正极通过限流电阻Rs和GPIO引脚连接（引脚输出高电平开启／低电平关闭）\n\n低电平：指示灯的负极与GPIO引脚连接（引脚输出高电平关闭／低电平开启），指示灯的正极通过限流电阻 Rs与电源连接\n\n在Nucleo开发板上，用 PA5引脚控制指示灯（采用高电平驱动方式）\n\n## 2．按键电路的设计（上拉式按键/下拉式按键）\n\n上拉式按键：一端与地相连，另外一端通过上拉电阻与电源连接，按键按下（下降沿），IO口读到低电平\n\n下拉式按键：一端与电源相连，另外一端通过下拉电阻接地，按键按下（上升沿），IO口读到高电平\n\n在Nucleo开发板上，用 PA13引脚控制按键（采用上拉式按键方式）\n\n## 3．外扩接口的设计（Arduino Uno/ST morpho）\n\nArduino Uno：CN5/CN6/CN8/CN9（单排插孔）\n\n![image-20240416213816539](https://cui1225.oss-cn-beijing.aliyuncs.com/img/image-20240416213816539.png)\n\n![image-20240416214212648](https://cui1225.oss-cn-beijing.aliyuncs.com/img/image-20240416214212648.png)\n\n\n\nST morpho：CN7/CN10（双排插针）\n\n![image-20240416214310377](https://cui1225.oss-cn-beijing.aliyuncs.com/img/image-20240416214310377.png)\n\n注：外扩时不要使用PA5这个引脚\n\n![image-20240416214338003](https://cui1225.oss-cn-beijing.aliyuncs.com/img/image-20240416214338003.png)\n\n注：外扩时不要使用PA3和PA2两个引脚\n\n## 4．与外界扩展版的连接方式（利用接口以层叠的形式进行连接/利用杜邦线进行连接外围模块）\n\n![image-20240416214711499](https://cui1225.oss-cn-beijing.aliyuncs.com/img/image-20240416214711499.png)","tags":["STM32"],"categories":["嵌入式"]},{"title":"stm32_Day1","url":"/2024/04/14/stm32-Day1/","content":"\n# 1.STM32 Nucleo开发板简介\n\n## 1.官方开发板\n\n1.Nucleo Borad（灵活搭建产品原型，使用最为广泛）\n\n2.Discovery Kit（针对芯片的重要性能进行参考评估）\n\n3.Evaluation Board（功能最为强大，可以对芯片的全部功能进行参考评估）\n\n## 2.Nucleo开发板电路特点\n\n1.模块化的设计（ST-Link仿真器+MCU核心板）\n\n2.统一的MCU核心板设计（一板多用）\n\n3.丰富的接口拓展（Arduino生态）\n\n4.简洁的外设模块（指示灯和按键）\n\n5.多功能的USB接口（虚拟串口，大容量存储，调试接口）\n\n6.灵活的供电方式（USB供电，外部供电）\n\n7.支出多种开发环境（MDK-ARM，EWARM，Mbed）\n\n![](https://gitee.com/yanyi-2004/picbed/raw/master/img/202504122132052.jpeg)\n\n最大的优势就是提供了ARDUINO的扩展接口\n\n## 3.按照引脚数量来分类(系列)\n\n1.Nucleo32\n\n2.Nucleo64\n\n3.Nucleo144\n\n![19c4dacb-fbcd-44bc-affb-8e816442e7f0](https://cui1225.oss-cn-beijing.aliyuncs.com/img/19c4dacb-fbcd-44bc-affb-8e816442e7f0.png)\n\n上半部分（ST-Link仿真器）\n\n下半部分（MCU核心板）\n\n## 4.电路模块\n\nCN4：SWD调试接口\n\nB1：用户按键\n\nLD3：电源指示灯\n\n主控芯片：STM32F411RET\n\nCN7：外扩引脚接口（便于用户二次开发）\n\nCN1：USB接口\n\nB2：复位按键\n\nLD2：用户指示灯\n\nCN5/6/8/9：Arduino接口\n\nCN10：外扩引脚接口（便于用户二次开发）\n\n## 5.STM32F411RET6 片内资源\n\n存储器方面：512KB Flash 和 128KB SRAM\n\n定时器方面：1个16位高级定时器，2个32位通用定时器，5个16位通用定时器\n\n连接接口方面：3路USART（串口），5路SPI/I2S，3路I2C，1路SDIO\n\nAD采集方面：1路12位16通道ADC\n\nUSB接口方面：1个全速USB 2.0 OTG\n\n数字IO数量方面：50个通用数字I/O口\n\n## 6.主控芯片的引脚(5大类)\n\n### 1.电源引脚\n\nVDD/VSS：为片内集成的数字外设供电（8个）\n\nVDDA/VSSA：为片内集成的模拟外设供电（2个）\n\nVBAT：为片内的实时时钟供电，确保断电后能正常工作（1个）\n\nVCAP_1：用于电源滤波（1个）\n\n### 2.复位及启动模式引脚\n\nNRST（复位引脚）：复位电平为低电平有效（1个）\n\nBOOT0，PB2（BOOT1）：启动引脚，两个引脚决定芯片的启动模式（2个）\n\n### 3.时钟引脚\n\nOSC32_IN,OSC32_OUT：接入外部低速时钟（2个）\n\nOSC_IN,OSC_OUT：接入外部高速时钟（2个）\n\n### 4.仿真调试引脚\n\nPA13,PA14：作为SWD的穿行调试接口（2个）\n\n### 5.通用数字I/O引脚]\n\n除了作为数字I/O意外，还作为片内外设的功能引脚\n\n# 2.Nucleo开发版最小系统设计\n\n微控制器最小系统的定义：\n\n狭义：仅包括电源电路，时钟电路，复位电路，调试电路及主控芯片电路\n\n广义：还包括基本的人机接口电路，如指示灯，按键，蜂鸣器，数码管及串口通信等电路\n\n以狭义为例：\n\n## 1.电源电路：为整个电路系统提供所需的供电电压\n\n两种供电方式：外部和USB\n\nVIN：外部供电端口（可以输入7V到12V的直流电压），经过电压转换芯片（LD1117S50TR）转换出5V的电源电压\n\nE5V：外部供电端口（可以输入5V的直流电压）\n\n+3V3：外部供电端口（可以输入3.3V的直流电压）\n\n**注：三个外部电源输入均引出到外扩接口**\n\nU5V：USB供电（可以输入5V的直流电压）\n\n最后通过JP5进行电源输入的选择，当2-3短接（外部供电），当2-1短接（USB供电），默认USB供电\n\nLD3用于指示电路板已经正常上电，再通过电压转换芯片（LD39050PU33R）转换出3.3V的供电电压（VDD），最后提供给目标MCU及外围电路\n\n## 2.时钟电路：为MCU提供所需的时钟信号\n\n**时钟源：**\n\n**LSI：内部低速时钟，由片内RC振荡器提供，默认频率32KHz**\n\n**HSI：内部高速时钟，由片内RC振荡器提供，默认频率16MHz**\n\n**HSE：外部高速时钟，通过OSC_IN和OSC_OUT引脚接入晶振实现，频率范围（4MHz-26MHz）,也可以直接接入外部时钟信号，频率范围（1MHz-50MHz）**\n\n**LSE：外部低速时钟，通过OSC32_IN和OSC32_OUT引脚接入32.768KHz的晶振实现**\n\n时钟电路的两种设计方法：震荡模式/旁路模式（一般使用震荡模式）\n\n外部高速时钟HSE：通过晶振X3和两个匹配电容C33和C34（阻值为20p）接入到OSC_IN和OSC_OUT引脚（默认没有焊接晶振X3），实际使用的时钟来自于ST-Link仿真器所提供的8MHz时钟，因此实际上Nucleo开发板上时钟电路选择的是旁路模式\n\n外部低速时钟LSE：通过晶振X2和两个匹配电容C31和C32（阻值为4.3p）接入到OSC32_IN和OSC32_OUT引脚。\n\n要想使用震荡模式（添加外部晶振）：\n\n1.断开焊桥SB16，SB50，SB54和SB55\n\n2.焊接8MHz石英晶体X3\n\n3.焊接2个20pF电容C33和C34\n\n4.焊接2个0欧电阻R35和R37或者用焊锡短接\n\n## 3.调试电路：位MCU提供程序下载和调试的接口\n\n两种调试接口（JTAG调试接口/SWD调试接口）\n\n![f36b90ad-198f-4e18-9861-a4fde7d34daf](https://cui1225.oss-cn-beijing.aliyuncs.com/img/f36b90ad-198f-4e18-9861-a4fde7d34daf.png)\n\n\n\n## 4.复位电路：为MCU提供统一的初始状态\n\n采用了传统的阻容复位电路（上电复位和手动复位）由MCU的复位引脚NRST内部的上拉电阻和电容C14g构成，阻容复位提供上电复位的功能，复位按键B2提供手动复位的功能，当B2按下（NRST与地连接）用于系统复位，在工程实际中，一般使用专用复位芯片（SP706S）来构成复位电路，可以提供标准的复位脉冲，还提供了电压监控\n\n## 5.主控芯片\n\n![67bdcbc5-0ad9-40ae-9af6-25ded7f9ed50](https://cui1225.oss-cn-beijing.aliyuncs.com/img/67bdcbc5-0ad9-40ae-9af6-25ded7f9ed50.png)\n\n![41a787f1-edaf-4a95-9ebd-3f2ea9d44f3b](https://cui1225.oss-cn-beijing.aliyuncs.com/img/41a787f1-edaf-4a95-9ebd-3f2ea9d44f3b.png)\n\n![66a1d9a2-ae4d-4019-a265-726c027f689e](https://cui1225.oss-cn-beijing.aliyuncs.com/img/66a1d9a2-ae4d-4019-a265-726c027f689e.png)\n\n| BOOT0 | BOOT1 | 启动模式    | 说明                       |\n|:-----:|:-----:|:-------:|:------------------------:|\n| 0     | X     | 用户闪存存储器 | 从MCU片内Flash启动，常用启动方式     |\n| 1     | 0     | 系统存储器   | 从系统存储器启动，主要用于串口下载（ISP模式） |\n| 1     | 1     | SRAM启动  | 从MCU片内SRAM启动，主要用于代码调试    |\n\n（0，X）用户闪存存储器是最常用的启动模式\n","tags":["STM32"],"categories":["嵌入式"]},{"title":"Java开发命令行程序","url":"/2024/04/10/Java开发命令行程序/","content":"\n# 一. 输入输出\n\n* 输入的作用，就是由使用者告诉程序要操作的数据\n  * 例如，我要通过饿了么订餐，你得告诉程序你要吃什么，送货地址是什么吧\n* 输出的作用，就是由程序向使用者展现执行的结果\n  * 还是订餐的例子，程序向你展示骑手接单没有，送到哪里了\n* 将来输入输出来源会有多种，比如 app，网页，终端程序等等\n\n## 1. System.out\n\n之前已经介绍过【标准输出】：System.out\n\n打开 jshell 用一下，回忆下对象和方法使用格式\n    对象.方法(参数);\n\n套用一下，对象是 System.out，方法是 println，参数是 \"你好\"\n    jshell> System.out.println(\"你好\");\n    你好\n\n小技巧\n\n* jshell 中用 `Tab` 键可以提示对象有哪些方法\n* jshell 中省略 `;` 也不会报错\n\n## 2. System.in\n\n再来看看输入，对象是 System.in，方法叫 read，没有参数\n    jshell> System.in.read();\n\n运行后，可以看到光标一闪一闪，表示正在等待用户的输入，这时输入小 a\n    jshell> System.in.read();\n    a\n    $1 ==> 97\n\n* 会显示 97，称之为返回值，代表 read() 读入的结果\n  \n  * 因为计算机中所有符号，都是用数字表示，参看下表\n\n* 前面的 $1 是一个【变量】，将来它就代表 97，也就是刚才输入的小 a\n\n* 【变量】可以反复被使用\n\n| \\    | 00  | 01  | 02  | 03  | 04  | 05  | 06  | 07  | 08  | 09  | 10  | 11  | 12  | 13  | 14  | 15  |\n| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 0000 | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   |\n| 0016 | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   |\n| 0032 |     | !   | \"   | #   | $   | %   | &   | '   | (   | )   | *   | +   | ,   | -   | .   | /   |\n| 0048 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | :   | ;   | <   | =   | >   | ?   |\n| 0064 | @   | A   | B   | C   | D   | E   | F   | G   | H   | I   | J   | K   | L   | M   | N   | O   |\n| 0080 | P   | Q   | R   | S   | T   | U   | V   | W   | X   | Y   | Z   | [   | \\   | ]   | ^   | _   |\n| 0096 | `   | a   | b   | c   | d   | e   | f   | g   | h   | i   | j   | k   | l   | m   | n   | o   |\n| 0112 | p   | q   | r   | s   | t   | u   | v   | w   | x   | y   | z   | {   | \\\\  |     | }   | ~   |\n\nSystem.in 的缺点\n\n1. 字符被转成的数字，不便人类阅读\n2. 只能输入一个字符\n\n## 3. Scanner\n\n用 Scanner 改进，System.in 是 java 为我们提供好的对象，而 Scanner 需要我们自己创建，语法是\n    jshell> new Scanner(System.in);\n    $2 ==> java.util.Scanner...\n\n将来这个 $2 就代表刚才的 Scanner 对象，我们称之为【变量】\n\nScanner 对象里面最常用的方法是 nextLine，用法如下\n    jshell> $2.nextLine();\n    你好啊\n    $3 ==> \"你好啊\"\n\n## 4. 变量名\n\n`$2`，`$3` 这样作为变量名虽然也可以，但如果用更有意义的名称来表示，更方便人类阅读、记忆。例如\n    jshell> var scanner = new Scanner(System.in)\n    scanner ==> java.util.Scanner[delimiters=\\p{javaWhitespace}+] ... \\E][infinity string=\\Q∞\\E]\n    jshell> var line = scanner.nextLine()\n    hello\n    line ==> \"hello\"\n\n* scanner 就代指输入对象\n* line 就代指用 nextLine() 读取到的字符串值\n* var 是关键字，代表某种类型，具体有哪些类型后面再展开\n\n## 5. 关键字\n\n变量取名时要注意两个规则，不能以数字开头，不能是关键字\n\n什么是关键字呢？关键字就是 java 中有特殊意义的单词，例如见过的有 class，var，new 等等，如果用 idea 中可以通过特殊颜色强调哪些单词是关键字，可以看到这些蓝色的单词都属于关键字\n\n至java 17 为止，共有 67 个关键字，参看这两份表格，这些关键字，都会在今后的课程中陆续学到\n\n\n\n\n\n# 二. 类型、变量、运算符\n\n## 1. 字符与字符串\n\n### 字符值与字符串值\n\n像这样用双引号引起来的值，在 Java 里称为字符串，字符串顾名思义，由多个字符组成，单个字符用单引号表示，例如\n    jshell> 'a'\n    $4 ==> 'a'\n    jshell> \"abc\"\n    $5 ==> \"abc\"\n\n* 单引号里必须由一个字符\n* 双引号里可以有零个、一个、多个字符\n\n### 转义字符\n\n比如我需要输出一个单引号字符值，`'''` 这样写行不行？本意是想表示中间的单引号，但遗憾的是java把前两个单引号当成了一对，把它当作了那个空字符了\n\n怎么办呢\n\n为了把真正的单引号跟语法的单引号区分开，需要给它加一个反斜杠标记，告诉java，我想表示真正的单引号，而不是语法中的单引号。试一下。\n    jshell> System.out.println(\"\\'\")\n    '\n\n这种结合了反斜杠的具有特殊含义的字符，称之为转义字符（Escape Character）\n\n常见的有七个：`\\' \\\" \\\\ \\n \\t \\b \\r` 刚才已经讲过单引号转义了\n\n继续来看几个例子\n    jshell> System.out.println(\"\\\"\") // 双引号转义\n    \"\n    jshell> System.out.println(\"\\\\\") // 反斜杠本身转义\n    \\\n    jshell> System.out.println(\"1\\n2\") // 换行\n    1\n    2\n\n    jshell> System.out.println(\"123\\t4\") // 缩进\n    123     4\n    \n    jshell> System.out.println(\"123\\b4\") // 退格\n    124\n    \n    jshell> System.out.println(\"123\\r4\") // 回车，退格是光标退一格，回车是退到头\n    423\n\n### 文本块\n\n最后再再来看看文本块，如果有一段文字内，其中需要有很多的转义字符，那么可读性会变得很差，例如\n    jshell> System.out.println(\"床前\\\"明月\\\"光，\\n疑是地上霜。\")\n\n因此在 java 14 这个版本引入了文本块来进行改善。\n    jshell> System.out.println(\"\"\"\n                               床前\"明月\"光，\n                               疑是地上霜。\"\"\")\n\n文本块本质上还是属于字符串值，由一对 三个双引号作为起始和结束标记，中间如果想表示双引号、换行这两个特殊字符，无需再转义表示\n\n* 一个注意事项是 \"\"\" 后需要换个行，不要紧接着写字符。\n\n## 2. 类型\n\n### 何为类型\n\n现在让用户输入两个数，求得相加结果\n    jshell> scanner.nextLine()\n    1\n    $22 ==> \"1\"\n    jshell> scanner.nextLine()\n    2\n    $23 ==> \"2\"\n    jshell> $22 + $23\n    $24 ==> \"12\"\n\n显然，这并不是我们想要的结果，它是输入的值当作了字符串，+ 号执行的是字符串连接操作，解决办法如下\n    jshell> scanner.nextInt()\n    1\n    $25 ==> 1\n    jshell> scanner.nextInt()\n    2\n    $26 ==> 2\n    jshell> $25 + $26\n    $27 ==> 3\n\nnextLine() 和 nextInt() 返回的类型是不同的\n\n* 前者返回的是字符串，类型为 String，+ 表示两个字符串连接\n* 后者返回的是整数，类型为 int，+ 表示两个整数相加\n\n### 数字类型\n\n| 类型名    | 说明           | 数字范围                                           | 类型后缀 |\n| ------ | ------------ | ---------------------------------------------- | ---- |\n| byte   | 整数类型，用1个字节表示 | $[-2^7,2^7)$ 即 $[-128,128)$                    |      |\n| short  | 整数类型，用2个字节表示 | $[-2^{15},2^{15})$                             |      |\n| int    | 整数类型，用4个字节表示 | $[-2^{31},2^{31})$                             |      |\n| long   | 整数类型，用8个字节表示 | $[-2^{63},2^{63})$                             | L    |\n| float  | 浮点小数，用4个字节表示 | $[-1.9999999 * 2^{127},1.9999999 * 2^{127}]$   | F    |\n| double | 浮点小数，用8个字节表示 | $[-1.9999999 * 2^{1023},1.9999999 * 2^{1023}]$ | D    |\n\n* `[]` 包含等于，`()` 不包含等于\n\n* 类型后缀\n  \n  * 不区分大小写，但建议用大写，因为小写的 L 与 1 容易混淆\n  * 尾符号 D 可以省略\n\n* float 和 double 精度不同，即小数点后的位数\n  \n  * float 的精度二进制是 23，换算成十进制是 6~7\n  * double 的精度二进制是 52，换算成十进制是 15~16\n\n### 字符类型\n\n| 类型名    | 说明              | 范围                          |\n| ------ | --------------- | --------------------------- |\n| char   | 字符类型，配合单引号      | $[0,2^{16})$ 即 $[0, 65536)$ |\n| String | 字符串类型，配合双引号或文本块 | -                           |\n\n## 3. 变量与运算符\n\n### 变量\n\n变量的定义格式为\n    类型 变量名 = 值;\n\n* 从语法可以看到，变量由类型和名称组成，类型决定了变量能存储的数据大小与数据格式，名字用来代表后面的值\n* 这个语法其实咱们前面见过类似的，var scanner = new Scanner(System.in)，这里 var 是类型，因为之前我们还没有学习具体有哪些类型，因此使用了 var 来代表某种类型，scanner是变量名，后面这一串就是值，也是 Scanner 对象\n\n= 称之为赋值运算符，可以用来更新变量代表的值。\n\n例如：\n    int a = 10\n\n这行代码的意思是，定义了整型变量a，更新它的初始值为10\n\n再来一句：\n    a = 20\n\n这时候为啥不用写前面的类型了呢，因为变量定义只需一次，定义好之后变量就可以反复使用了，这行代码的意思是，将 a 所代表的值更新为 20\n\n变量可以用来保存运算的结果，它自身也能参与运算\n\n### 运算符\n\n    int a = 5 + 3\n\n结果为 8\n    int a = 5 - 3\n\n结果为 2\n    int a = 5 * 3\n\n结果为 15\n    int a = 5 / 3\n\n结果为 1，整数除法有两个注意点\n\n* 整数除法，只会保留商，而小数部分会被舍弃，并不考虑四舍五入\n\n* 除0是不合法的，会出错\n    int a = 5 % 3\n\n结果为 2\n\n小数加减乘除与整数类似，只是小数除法可以保留小数点后的数字，而且可以除零，例如\n    jshell> 5.0 / 3.0\n    $40 ==> 1.6666666666666667\n    jshell> 5.0 / 0.0\n    $41 ==> Infinity\n\n增强赋值运算符\n    int a = 20; \n    a = a + 10;\n\n意思是，获取 a 的原有值 20，执行加 10 运算，将新的结果重新赋值给 a，a 代表的值被更新成了 30。可以用 += 增强赋值运算符达到类似的效果\n    a += 10;\n\n先不要看 = 号，获取 a 的原有值 30，执行加 10 运算，运算的结果 40 赋值给 a\n    a -= 10;\n\n先拿 a 的原有值 40 与后面的 10 做减法，再将结果 30 赋值给 a\n\n自增自减运算符\n\n两个特殊运算符 ++ 与 --\n\n++ 是让变量自增1，-- 是让变量自减1，举个例子\n    int a = 10;\n    a++;\n\n结果为 11，++ 和 -- 既可以写在变量之前，也可以写在变量之后，这两种写法的区别，我们到高级篇再讲，目前暂不用去了解\n\n## 4. 练习 - 房贷计算器\n\n【等额本息还款】法计算房贷\n\n> 术语\n> \n> * 等额本息是指一种贷款的还款方式，是在还款期内，每月偿还同等数额的贷款（包括本金和利息）\n> \n> * 每月偿还的贷款可以通过下述公式计算$p * r * (1 + r)^m / ((1 + r)^m - 1)$\n>   \n>   * p 为贷款本金 principal\n>   * r 为月利率 monthlyInterestRate\n>   * m 为还款月数 months\n\n公式中这些都是什么意思呢\n\n例如：贷款 200 万元 ，对应公式中的 p，200 万就是贷款本金，年利率 6%，月利率 mr 就是 6% / 12 = 0.5%，假设 10 年还清，这时还款月数就是 360 个月。套入公式计算即可得到每月还多少钱\n\n要完成这个计算，有一点没学过的是求这里的 1+ mr 的 m 次方，计算它需要用一个求幂方法，这个方法是 jdk 核心类库中 Math 这个类提供的，Math的字面意思是数学，Math 类中提供了很多与数学计算相关的方法，如果你以后有这方面需求，就找它。\n\n### Math.pow()\n\npow 是 static 方法，语法为 `类名.方法名(参数值)`，它需要两个参数，参数1是底数，参数2是指数\n    jshell> Math.pow(2.0, 1)\n    $42 ==> 2.0\n    jshell> Math.pow(2.0, 2)\n    $43 ==> 4.0\n    jshell> Math.pow(2.0, 3)\n    $44 ==> 8.0\n\n解答\n\n打开 idea，编写 Calculator 类\n    public class Calculator {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"请输入贷款本金 p\");\n            double p = scanner.nextDouble();\n            System.out.println(\"请输入年利率 r%\");\n            double yr = scanner.nextDouble();\n            double mr = yr / 100.0 / 12.0;\n\n            System.out.println(\"请输入贷款月数 m\");\n            int m = scanner.nextInt();\n    \n            System.out.println(p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1));\n        }\n    }\n\n### 数字格式化\n\n对结果的数字进行格式化，让它以货币的格式来显示\n\n需要借助核心类库中一个 NumberFormat 对象，字面意思是数字格式化，使用它的 getCurrencyInstance 方法来获取一个货币格式化对象，再使用它的 format 方法把 double 小数格式化为货币格式，格式化时也会保留两位小数\n\n例子\n    System.out.println(NumberFormat.getCurrencyInstance(Locale.CHINA).format(1000000.00));   System.out.println(NumberFormat.getCurrencyInstance(Locale.US).format(1000000.00));\n    System.out.println(NumberFormat.getCurrencyInstance(Locale.GERMANY).format(1000000.00));\n    System.out.println(NumberFormat.getCurrencyInstance(Locale.KOREA).format(1000000.00));\n\n输出\n    ¥1,000,000.00\n    $1,000,000.00\n    1.000.000,00 €\n    ₩1,000,000\n\n如果 Locale 省略不写，默认为中国\n\n房贷计算器可以改写为\n    double payment = p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);       System.out.println(NumberFormat.getCurrencyInstance().format(payment));\n\n### 查阅 Javadoc\n\n练习做完了，大家学到了什么呢？\n\n有同学说，学会怎么算每月还款了，是吗？并不是，通过这个例子，要认识到 java 核心类库能帮我们解决很多问题，比如说求幂运算，比如说数字格式化，包括之前学过的 Scanner 都是核心类库提供的功能，这就提醒我们，要解决某个编程问题之前，要先想一想核心类库有没有这方面的功能，如果有拿来用就行了，不必自己重新实现某项功能的代码，我们是站在巨人的肩膀上进行编程的。\n\n当然，同学们并不是一开始就知道核心类库都提供了哪些功能，因此，这就需要我们不断去熟悉核心类库，熟悉它都有哪些类，哪些方法，比较重要的功能都在后续的课程中都会陆续介绍到，当然呢，同学们也不能总等着老师来喂知识，也可以自己查阅 javadoc 来扩展自己的知识面\n\njavadoc 就是 java documentation 的缩写，我们下载的 jdk 中已经自带了，无需额外再下载。那怎么查阅 javadoc 呢，如果大家用的是 idea，那么可以通过一些快捷键来查阅java文档\n\n* 比如想看看类的文档，这时先按 Ctrl + N 查找类，假设我想看 Math 类的文档，输入要查阅的类名 Math，回车，可以跳转到这个类\n\n* 接下来我想看看方法的文档怎么办呢，按一下 ctrl + f12，列出当前类的所有方法，绿色表示可以使用方法，橙色带锁的，表示是该类一种特殊的私有方法，不能直接使用。找感兴趣的方法时，如果你懂一些英文单词，那么会有一定优势，例如你想找一个平方根方法，它对应的英文是 sqrt，这时敲入这几个字母，就会定位到方法，同样可以用翻译查看该方法的功能\n\n* 可以查到它的作用：返回一个数的平方根，这是方法名，查看后面括号内可以得知，需要一个参数，代表要求平方根的那个数字，是一个double 小数，方法名称前还有个 double 表示它的结果类型也是一个 double 小数\n\n* Math 中的方法大部分都是 static 方法，也就是配合类名使用的方法，之前也说过，用法为 类名.方法名(参数)\n\n在平时写代码时，如果忘记了某个方法的作用，可以光标定位到该方法，按 Ctrl + Q 进行查阅，效果是类似的\n\n# 三. 条件语句\n\n编程时有一种重要的语句叫做条件语句，之前我们学过的都属于顺序语句，也就是从上至下，依次要执行每一行代码。\n\n但是有的情况下，我们并不希望所有代码都执行，而是希望满足条件的代码才执行\n\n例如：要对用户输入数据的合法性进行检查：\n\n* 贷款本金必须大于0\n* 贷款月数范围在 1 ~ 360 之间\n* 年利率范围在 1% ~ 36% 之间\n\n如果你输入的值连这些条件都不满足，有必要去计算每月还款金额吗？\n\n这种情况下，就要用到条件语句了，它的语法格式为\n    if(条件) {\n        // 条件为 true 执行这里\n    } else {\n        // 条件为 false 执行这里\n    }\n\n什么意思呢，if 本意是如果，如果条件成立，执行代码1，else 本意是否则，即条件不成立，执行代码2，其中 `else { }` 语句块不是必须的，可以省略\n\n那么条件这部分怎么写呢？对于数字类型可以借助比较运算符的运算结果来充当条件，参考下面的表格，这种表格列出了所有比较运算符\n\n| 比较运算符  | 含义             |     |\n| ------ | -------------- | --- |\n| a == b | 判断 a 与 b 是否相等  |     |\n| a > b  | 判断 a 是否 > b    |     |\n| a >= b | 判断 a 是否 >= b   |     |\n| a < b  | 判断 a 是否 < b    |     |\n| a <= b | 判断 a 是否 <= b   |     |\n| a != b | 判断 a 与 b 是否不相等 |     |\n\n## 1. boolean 类型\n\n判断的结果是布尔类型，可以充当条件，它的取值非真即假，真用 true 表示，假用 false 表示\n\n## 2. 单条件\n\n    jshell> int a = 1000;\n    a ==> 1000\n    \n    jshell> if(a > 0){\n       ...>     System.out.println(\"ok\");\n       ...> } else {\n       ...>     System.out.println(\"必须>0\");\n       ...> }\n    ok\n    \n    jshell> a = -1000;\n    a ==> -1000\n    \n    jshell> if(a > 0){\n       ...>     System.out.println(\"ok\");\n       ...> } else {\n       ...>     System.out.println(\"必须>0\");\n       ...> }\n    必须>0\n\n房贷计算器改写如下\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入贷款本金 p\");\n        double p = scanner.nextDouble();\n        if(p > 0) {\n            System.out.println(\"请输入年利率 r%\");\n            double yr = scanner.nextDouble();\n            double mr = yr / 100.0 / 12.0;\n            System.out.println(\"请输入贷款月数 m\");\n            int m = scanner.nextInt();\n\n            double payment = p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);\n            System.out.println(NumberFormat.getCurrencyInstance().format(payment));\n        } else {\n            System.out.println(\"贷款金额必须大于0\");\n        }\n    \n    }\n\n## 3. 多条件\n\n刚才我们在判断贷款本金的时候，只需要有一个大于 0 的条件就可以了，但是接下来我们要去检查年利率的时候，他是在一个范围之间，这就必须有两个条件，一个条件呢是要让年利率大于等于 1%，第二个条件呢，是让上年利率必须小于等于 36%，而且呢这两个条件你必须同时成立\n\n多个条件可以用逻辑运算符连接\n\n| 逻辑运算符      | 含义                           |     |\n| ---------- | ---------------------------- | --- |\n| 条件1 && 条件2 | && 意思是并且，两个条件必须同时成立，结果为 true |     |\n| 条件1 \\\\     | \\\\                           | 条件2 |\n| ! 条件       | ! 意思是取反                      |     |\n\n举例\n    jshell> int b = 120;\n    b ==> 120\n    jshell> if(b >= 1 && b <= 360) {\n       ...>     System.out.println(\"ok\");\n       ...> } else {\n       ...>     System.out.println(\"必须在1~360之间\");\n       ...> }\n    ok\n    jshell> b = 0\n    b ==> 0\n\n    jshell> if(b >= 1 && b <= 360) {\n       ...>     System.out.println(\"ok\");\n       ...> } else {\n       ...>     System.out.println(\"必须在1~360之间\");\n       ...> }\n    必须在1~360之间\n    \n    jshell> b = 361\n    b ==> 361\n    \n    jshell> if(b >= 1 && b <= 360) {\n       ...>     System.out.println(\"ok\");\n       ...> } else {\n       ...>     System.out.println(\"必须在1~360之间\");\n       ...> }\n    必须在1~360之间\n\n房贷计算器改写如下\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入贷款本金 p\");\n        double p = scanner.nextDouble();\n        if(p > 0.0) {\n            System.out.println(\"请输入年利率 r%\");\n            double yr = scanner.nextDouble();\n            if (yr >= 1.0 && yr <= 36.0) {\n                double mr = yr / 100.0 / 12.0;\n                System.out.println(\"请输入贷款月数 m\");\n                int m = scanner.nextInt();\n                if (m >= 1 && m <= 360) {\n                    double payment = \n                        p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);\n                    System.out.println(NumberFormat.getCurrencyInstance()\n                                       .format(payment));\n                } else {\n                    System.out.println(\"贷款月数范围在 1 ~ 360 之间\");\n                }\n            } else {\n                System.out.println(\"年利率范围在 1% ~ 36% 之间\");\n            }\n        } else {\n            System.out.println(\"贷款金额必须大于0\");\n        }\n    }\n\n## 4. 相反条件\n\n我们这段代码，逻辑上没错，但你会发现不容易阅读\n\n多层 if 嵌套导致代码的可读性变得很差，一旦大家写代码时出现了两层以上的 if 语句，就要小心了。如何改进呢？\n\n这里给同学们介绍一种方法：可以去除 else 提高代码可读性\n\n比如，现在有两个分支，c 是一个条件，要么走分支1，要么走分支2，用下面的 if else 可以表示\n    if(c) {\n        // 分支1\n    } else {\n        // 分支2\n    }\n\n等价于\n    if(!c) {\n        // 分支2\n    } else {\n        // 分支1\n    }\n\n能不能不写 else 呢？假设进入了分支2，分支2的代码执行后，程序还会继续向下执行，导致分支1也被执行\n    if(!c) {\n        // 分支2\n    }\n    // 分支1\n\n可以改写为下面的形式，这样就避免了 else 出现\n    if(!c) {\n        // 分支2\n        return; \n    }\n    // 分支1\n\n总结一下，以上代码的等价转换，有一句口诀：条件取反，if else 倒置，return 一加， else 可去\n\n变换有一定的规律：\n\n| 原条件                     | 相反条件1                      | 相反条件2       |\n| ----------------------- | -------------------------- | ----------- |\n| p > 0.0                 | !(p > 0.0)                 | p <= 0.0    |\n| yr >= 1.0 && yr <= 36.0 | !(yr >= 1.0 && yr <= 36.0) | yr < 1.0 \\\\ |\n| m < 1 \\\\                | \\\\                         | m > 360     |\n\n* 用逻辑与连接的两个条件，可以两个条件分别取反，然后&&变||\n  \n  * 年利率>=1.0 并且<=36.0 的相反条件是：年利率<1.0 或者 年利率>36.0\n\n* 用逻辑或连接的两个条件，可以两个条件分别取反，然后||变&&\n\n这种逻辑变换规律称之为反演规则，公式记不住没关系，简单的反演我们自己就能想出来，复杂的变换才用公式保证正确性\n\n房贷计算器改写如下\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入贷款本金 p\");\n        double p = scanner.nextDouble();\n        if (p <= 0.0) {\n            System.out.println(\"贷款金额必须大于0\");\n            return;\n        }\n        System.out.println(\"请输入年利率 r%\");\n        double yr = scanner.nextDouble();\n        if (yr < 1.0 || yr > 36.0) {\n            System.out.println(\"年利率范围在 1% ~ 36% 之间\");\n            return;\n        }\n        double mr = yr / 100.0 / 12.0;\n        System.out.println(\"请输入贷款月数 m\");\n        int m = scanner.nextInt();\n        if (m < 1 || m > 360) {\n            System.out.println(\"贷款月数范围在 1 ~ 360 之间\");\n            return;\n        }\n        double payment = p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);\n        System.out.println(NumberFormat.getCurrencyInstance().format(payment));\n    }\n\n# 四. 循环语句\n\n## 1. 循环语句语法\n\n    for(初始化变量; 终止条件; 更新变量) {\n        // 循环体代码\n    }\n\n1. 初始化部分仅执行一次\n2. 执行终止条件，如果为 true 继续循环，如果为 false 退出循环\n3. 执行循环体代码\n4. 执行迭代部分，从 2 开始执行\n\n例如\n    for(int i = 0; i < 3; i++) {\n        System.out.println(i);\n    }\n\n执行流程如下\n\n1. 声明一个变量 i，初始值为 0，用来控制循环次数\n2. 判断 i < 3，此时 i 取值是 0，条件为 true，继续循环\n3. System.out.println(0)\n4. i++，自增为 1\n5. 判断 i < 3，此时 i 取值是 1，条件为 true，继续循环\n6. System.out.println(1)\n7. i++，自增为 2\n8. 判断 i < 3，此时 i 取值是 2，条件为 true，继续循环\n9. System.out.println(2)\n10. i++，自增为 3\n11. 判断 i < 3，此时 i 取值是 3，条件为 false，退出循环\n\n## 2. 变量的作用范围\n\n上例中 i 的作用范围，仅在循环语句的 {} 内有效，现在要求求 1~100 的整数和，则需要把 sum 这个变量定义在 {} 外层\n    int sum = 0;\n    for (int i = 1; i <= 100; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n\n这里能否这样写\n    for (int i = 1; i <= 100; i++) {\n        int sum = 0;\n        sum += i;\n    }\n    System.out.println(sum);\n\n不行，变量有它们各自的作用范围，从变量的定义开始，找到包围它的，右 } 括号为止。\n\n* 在它上面用它\n* 在右括号外用它\n\n## 3. 练习 - 贷款计算详情\n\n现在需要计算每月偿还的利息、偿还的本金、剩余的本金\n\n例如，借款 1000 元，利息 100%，两月还清，根据公式计算出来每月还款 1333.33\n\n| 月份  | 本月还款    | 偿还本金    | 偿还利息    | 剩余本金   |\n| --- | ------- | ------- | ------- | ------ |\n| 1   | 1333.33 | 333.33  | 1000.00 | 666.67 |\n| 2   | 1333.33 | 666.67  | 666.67  | 0      |\n| 总额  | 2666.67 | 1000.00 | 1666.67 |        |\n\n可以看到\n\n* $偿还利息 = 剩余本金 * 月利率$\n* $偿还本金 = 每月还款 - 偿还利息$\n\n房贷计算器改写如下\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入贷款本金 p\");\n        double p = scanner.nextDouble();\n        if (p <= 0.0) {\n            System.out.println(\"贷款金额必须大于0\");\n            return;\n        }\n        System.out.println(\"请输入年利率 r%\");\n        double yr = scanner.nextDouble();\n        if (yr < 1.0 || yr > 36.0) {\n            System.out.println(\"年利率范围在 1% ~ 36% 之间\");\n            return;\n        }\n        double mr = yr / 100.0 / 12.0;\n        System.out.println(\"请输入贷款月数 m\");\n        int m = scanner.nextInt();\n        if (m < 1 || m > 360) {\n            System.out.println(\"贷款月数范围在 1 ~ 360 之间\");\n            return;\n        }\n        double payment = p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);\n        System.out.println(NumberFormat.getCurrencyInstance().format(payment));\n        double totalInterest = 0.0;                 // 总利息\n        for (int i = 1; i <= m; i++) {\n            double interest = p * mr;               // 每月偿还利息\n            double principal = payment - interest;  // 每月偿还本金\n            p -= principal;                         // 剩余本金\n            totalInterest += interest;\n            System.out.print(i);\n            System.out.print(\"\\t本月还款:\" + \n                             NumberFormat.getCurrencyInstance().format(payment));\n            System.out.print(\"\\t偿还本金:\" + \n                             NumberFormat.getCurrencyInstance().format(principal));\n            System.out.print(\"\\t偿还利息:\" + \n                             NumberFormat.getCurrencyInstance().format(interest));\n            System.out.println(\"\\t剩余本金:\" + NumberFormat.getCurrencyInstance().format(p));\n        }\n        System.out.print(\"总还款额:\" + \n                         NumberFormat.getCurrencyInstance().format(payment * m));\n        System.out.println(\"\\t总利息:\" + \n                           NumberFormat.getCurrencyInstance().format(totalInterest));\n    }\n\n# 五. 方法\n\n将来代码多了，全部写在 main 方法里，会显得非常凌乱，难于阅读。这节课的目标是使用方法来改写前面的代码。\n\n## 1. 定义方法\n\n先来了解一下定义方法的语法\n    [访问修饰符] [static] 返回结果类型 方法名([参数类型1 参数名1, 参数类型2 参数名2, ...]) {\n        // 方法体\n        return 返回结果\n    }\n\n* 其中用 [] 的（[] 不是语法的一部分）是可选部分\n* 访问修饰符先省略不写，后面再讲\n* static 这里先写上，这个前面提过，用 static 修饰的方法不属于对象\n* 方法执行完毕后可能会有返回结果\n  * 如果没有返回结果，返回值类型填写 void\n  * 如果有返回结果，填写实际的类型，例如\n    * 返回整数，填写 int\n    * 返回小数，填写 double\n* 方法名随便起，但应当做到望文生义\n* 参数是方法执行时需要传入的数据，可以有零到多个，格式为【参数类型 参数名】，多个参数之间用逗号分隔\n* {} 内写方法的具体代码\n* 最后 return 用来结束方法的运行，如果方法有返回结果，也需要配合 return 把结果传递给调用者\n\n例如，想计算一下两个整数的和\n    class Test {\n        static int add(int a, int b) {\n            return a + b;\n        }\n    }\n\n## 2. 调用方法\n\n回忆一下 Math.pow(2.0, 2) 就是一个由 java 提供好的 static 方法，它怎么用呢，Math 是类名，pow 是方法名，括号内是参数，对于我们自己写的 static 方法，用法是类似的：\n    类名.方法名([参数值1, 参数值2, ...])\n\n即\n    Test.add(100,200);\n\n怎么拿到返回结果呢？\n    int c = Test.add(100,200);\n\n如果是调用本类 static 方法，可以省略前面的类名\n\n## 3. 方法的意义\n\n学完了方法的定义、调用流程，再来看看方法的意义\n\n方法的一个意义在于隐藏实现细节：\n\n例如，对于前面例子中的【等额本息】方式计算房贷，如果没有方法，那就要求编程者必须非常清楚计算公式\n    double payment = p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);\n\n假设有一位资深程序员（例如你）提供了计算房贷方法，那么编程者就只需要知道：\n\n计算等额本金还款，需要一个名字叫calculate的方法\n\n它需要三个参数，... ，至于具体的计算过程，被隐藏在了方法内部\n    double payment = calculate(p, mr, m);\n\n* p 贷款本金\n* mr 月利率\n* m 贷款月数\n\n对于使用它的小白程序员来讲，无需了解它的实现细节，直接拿来用就可以了。小白程序员是站在你的肩膀上编程\n\n方法的另一个意义在于减少重复代码、提高代码的可维护性：\n\n对比以下代码，第一段是没用方法，如果有一处写错了，所有重复的地方都得修改\n    double p1 = p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);\n    double p2 = p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);\n    double p3 = p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);\n\n用了方法，万一写错，只需要一个地方的代码需要修改\n    static double calculate(double p, double mr, int m) {\n        return p * mr * Math.pow((1 + mr), m) / (Math.pow((1 + mr), m) - 1);\n    }\n\n## 4. 练习 - 贷款计算 - 方法改写\n\n    public class Calculator3 {\n        public static void main(String[] args) {\n            double p = inputAndCheckP();\n            double mr = inputAndCheckMr();\n            int m = inputAndCheckM();\n            double payment = Calculator3.calculate(p, mr, m);\n            printDetails(p, mr, m, payment);\n        }\n    \n        static double inputAndCheckP() {\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"请输入本金\");\n            double p = scanner.nextDouble();\n            if(p <= 0) {\n    //            System.out.println(\"贷款金额必须 > 0\");\n                // throw new 异常类型(\"提示信息\")\n                throw new IllegalArgumentException(\"贷款金额必须 > 0\");\n            }\n            return p;\n        }\n    \n        static double inputAndCheckMr() {\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"请输入年利率\");\n            double yr = scanner.nextDouble();\n            if(yr < 1.0 || yr > 36.0) {\n                throw new IllegalArgumentException(\"年利率必须是 1 ~ 36\");\n            }\n            return yr / 12.0 / 100;\n        }\n    \n        static int inputAndCheckM() {\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"请输入还款月数\");\n            int m = scanner.nextInt();\n            if(m < 1 || m > 360) {\n                throw new IllegalArgumentException(\"贷款月数必须是 1 ~ 360\");\n            }\n            return m;\n        }\n    \n        static void printDetails(double p, double mr, int m, double payment) {\n            for (int i = 0; i < m; i++) {\n                double payInterest = p * mr;                    // 偿还利息\n                double payPrincipal = payment - payInterest;    // 偿还本金\n                p -= payPrincipal;                              // 剩余本金\n                System.out.print (\"月份:\" + (i + 1));\n                System.out.print(\"\\t本月还款:\" + NumberFormat.getCurrencyInstance().format(payment));\n                System.out.print(\"\\t偿还本金:\" + NumberFormat.getCurrencyInstance().format(payPrincipal));\n                System.out.print(\"\\t偿还利息:\" + NumberFormat.getCurrencyInstance().format(payInterest));\n                System.out.println(\"\\t剩余本金:\" + NumberFormat.getCurrencyInstance().format(p));\n            }\n            System.out.println(\"总还款额:\" + NumberFormat.getCurrencyInstance().format(payment * m));\n        }\n\n\n​    \n​        /**\n​         * 以等额本息方式计算每月还款金额\n​         * @param p 本金\n​         * @param mr 月利率\n​         * @param m 还款月数\n​         * @return 每月还款金额\n​         */\n​        static double calculate(double p, double mr, int m) {\n​            double pow = Math.pow(1 + mr, m);\n​            return p * mr * pow / (pow - 1);\n​        }\n​    }\n\n### 说明1\n\n大家抽取方法时有一个原则，就是把一组完整功能，所对应的多行代码抽取为一个方法，这里我们把计算还款总额和计算还款详情，分别抽取了两个方法\n\n* calculate\n* printDetails\n\n抽取时，要点如下\n\n* 方法名要见文知义\n* 返回值不着急写，看看方法的外部需不需要用到这个方法内的变量\n  * 需要，返回值定义为结果类型\n  * 不需要，返回值定义为 void\n* 参数也不着急写，看方法内缺哪些变量定义，以它们为方法参数\n\n### 说明2\n\n对于 calculate 这种比较重要的方法定义，最好给它加一个文档，你得告诉将来这个方法的使用者，怎么用这个方法，每个参数是什么意思。\n\n先写斜杠两个星号的开始，不用着急写它的结束，直接一回车。idea 就会自动生成一段 javadoc 文档，你可以在这里介绍方法的作用\n\n* 在 @param 这里对每个参数进行说明\n* 在 @return 这里对返回值进行说明。\n\n### 说明3\n\n如果在某些验证不通过，想让剩余代码不要运行，可以利用 throw 语法\n\n* return 这种语法叫正常返回，也就是当方法调用后，代码还会继续运行\n* 还有就是这种throw 语法，它称为异常返回，如果没有额外处理，代码从方法调用后就中断运行\n\n# 六. package 与 jar\n\n## 1. package\n\n随着我们写的类越来越多，把他们都放在一块儿来管理，感觉比较的不规范，因此，我们要引入一个新的package语法，对源文件进行一个更好的管理。\n\n其实这个package说白了就是Java中一种目录结构\n    |- 包1\n        |- 从属于包1 的类\n    |- 包2\n        |- 从属于包2 的类\n\n语法：\n    package 包名; // 告诉下面的类从属于此包\n    class 类 {\n    }\n\n包的命名一般都是域名的倒置，如\n\n* baidu.com 域名的倒置就是 com.baidu\n* bilibilicom 域名的倒置就是 com.bilibili\n\n## 2. import\n\n与 package 关系非常密切的一个语法：import，如果你的类想使用另外一个类，而两个类不同包，这时就必须用 import，把另一个类导入进来才能使用\n    package com.itheima.a;\n    import java.util.Scanner;\n    class Calulator {\n        public static void main(String[] args) {\n            // 要用到 Scanner, 这时就用用到上面的 import 语句\n        }\n    }\n\n* 有一种特殊情况不需要 import 导入，即 java.lang 包下的类使用时，都不需要 import\n\n## 3. jar\n\n代码写完了，我们最终要发布成品吧，那是把源文件直接给使用者吗？显然不是吧。最终交给 jvm 运行的是 class 类文件，我们会把这多个 class 类文件打成一个压缩包，交付给用户。\n\n用 idea 可以方便地打包\n\n步骤1：创建工件（artifact）\n\n\n\n步骤2：构建工件\n\n\n\n步骤3：运行 jar 包，需要客户电脑上安装好 jdk\n    java -jar jar包文件名\n","tags":["Java"],"categories":["编程"]},{"title":"Java基础","url":"/2024/04/10/Java基础/","content":"\n# 一. Java 简介\n\nJava 是第一大编程语言和开发平台。它有助于企业降低成本、缩短开发周期、推动创新以及改善应用服务。如今，Java 仍是企业和开发人员的首选开发平台，全球有数百万开发人员运行超过 51 亿台 Java 虚拟机。\n\n## 1. JVM\n\n* 它是 Java Virtual Machine 也就是 Java 虚拟机的缩写，它的职责是解释执行Java代码。我们写好的 Java 代码，并不能被直接运行，而是需要交给 JVM 来解释执行\n* 很多公司都提供了 JVM 实现，最为知名的是 Oracle 提供的 JVM 实现\n\n## 2. JRE\n\n* JRE呢，是 Java runtime environment 的缩写，含义是 Java 的运行环境。Java 代码编写好了以后，不仅是需要 JVM 对它来进行解释，而且也需要一些基础功能的配合，这些基础功能呢，称之为核心类库（Core libraries），JVM 和核心类库加在一起，就构成了 JRE 这个运行环境\n\n## 3. JDK\n\n* JDK是 Java development kit 的缩写，含义是 Java 的开发环境。如果你不仅仅要运行 Java 程序，还想开发新的 Java 程序，那还需要借助一些开发工具，JRE 跟开发工具合在一起，就构成了JDK\n\n\n\n通过刚才的讲解，我们了解到 JVM、JRE、JDK 之间是一个包含的关系：\n\n* JDK 功能最全，包含了 JRE 和开发工具\n* 其次是 JRE，包含了 JVM + 核心类库\n* 最后是 JVM，负责解释执行我们的 Java 代码\n\n因此，对于后面的学习，我们只需要下载安装 JDK 就可以进行 Java 开发了\n\n> 从 Java 11 这个版本开始，不再单独提供 JRE\n> \n> * In this release, the JRE or Server JRE is no longer offered. Only the JDK is offered. Users can use `jlink` to create smaller custom runtimes.\n\n# 二. 安装 JDK\n\n## 1. 下载和安装\n\n这里介绍 Windows 10 平台下 Oracle 的 JDK 安装\n\n入口在哪儿？访问 oracle 官网 [Oracle | Cloud Applications and Cloud Platform](https://www.oracle.com/index.html)\n\n\n\n点击 Java 后进入下面的页面\n\n\n\n下载页面让我们选择版本，这里选择 Java 17，因为它是长期支持版（LTS）\n\n* 18 虽然看着新，但实际上到 2022.9 就会被 19 取代\n* 而 17 的支持会到 2024 年\n\n接下来选择平台，这里选择 Windows，其它平台下 JDK 的安装，请关注我们后续的视频\n\nWindows 有三个版本，第一个是解压版，后两个是安装版。初学者我建议下载解压版（有助于理解 java 程序的查找过程）\n\n\n\n下载完毕后，解压到一个**没有中文和空格**的目录即可\n\n## 2. 配置 Path\n\n你可以选择一个喜欢的目录，我的解压目录是 d 盘根目录下，如图所示\n\n* 其中 bin 目录下包含的就是它所带的一些开发和运行工具\n* 像 Javac.exe 还有 Java.exe 都是较为重要的，后面都会用到\n\n\n\n验证安装是否成功：按快捷键 `Win + r`，输入命令提示符程序名称 `cmd`\n\n\n\n出现命令提示符窗口，输入 `java -version`\n    C:\\Users\\Lenovo>java\n    'java' 不是内部或外部命令，也不是可运行的程序\n    或批处理文件。\n\n这是因为 cmd 程序并不知道 java 的安装位置，因此没有找到它\n\n* 可以输入它的全路径来找到它\n  \n  * 比如，我的 java 解压到了 D:\\jdk-17.0.3.1 这个目录，这时全路径就是 D:\\jdk-17.0.3.1\\bin\\java\n  * 但显然这么做比较麻烦\n\n* 更好的方式是配置 Path【环境变量】\n\n按快捷键 `win` 搜索【此电脑】，出现下面的界面\n\n\n\n点击【属性】，找到【高级系统设置】\n\n\n\n按下图箭头顺序找到**新建**，把刚才 jdk 的解压目录 + bin 补充填入，我这里是 D:\\jdk-17.0.3.1\\bin，全部确定。\n\n\n\n> Path 环境变量的作用：\n> \n> * Path 环境变量中记录的是程序执行时的搜索路径\n> * cmd 执行一个程序时，即使未给出完整路径，也会在 Path 环境变量列出的目录下依次查找该程序\n>   * 找到了，则执行\n>   * 都找不到，才报错\n> * 因此对刚才的问题，只需将 java 程序的所在目录补充进 Path 环境变量\n\n环境变量改动后，原有的 cmd 窗口是不受影响的，要想生效**必须**打开一个新的 cmd 窗口，输入 `java -version`，如果出现类似于下面的输出，表示成功\n    C:\\Users\\Lenovo>java -version\n    java version \"17.0.2\" 2022-01-18 LTS\n    Java(TM) SE Runtime Environment (build 17.0.2+8-LTS-86)\n    Java HotSpot(TM) 64-Bit Server VM (build 17.0.2+8-LTS-86, mixed mode, sharing)\n\n## 3. 配置 JAVA_HOME（选讲）\n\n网上的一些教程，都会让大家配置另一个叫做 JAVA_HOME 的环境变量，代表的是 JDK 的安装根目录。\n\n* 其实这个环境变量你可以不配，对于后续学习几乎没有影响\n* 例外情况是，有的 java 程序，例如后面学到的 Tomcat 在启动时，会用到 JAVA_HOME 环境变量，但这属于个别现象，等我们学到它时再解决不迟\n* 还有一个不配 JAVA_HOME 的理由：如果将来有不同的应用运行需要版本的 JDK，这时还不如不配全局 JAVA_HOME，让每个程序在启动脚本里指定自己需要的 JAVA_HOME\n\n出于知识的完整性，我们演示一下如何配置 JAVA_HOME，还是找到环境变量的配置窗口，在系统环境变量处点击新建，输入变量名和变量值，JAVA_HOME 名称是固定的，注意全大写，值是 JDK 的安装根目录，我这里是 D:\\jdk-17.0.3.1\n\n### 优化\n\n配完之后，发现 PATH 环境变量中的 D:\\jdk-17.0.3.1\\bin 与 JAVA_HOME 中的 D:\\jdk-17.0.3.1 有一部分重复了，这样的问题是如果将来切换 jdk 版本，如果改了一处，忘记改另一处，就会造成不一致。\n\n可以把 PATH 的取值修改为 %JAVA_HOME%\\bin，其中 %JAVA_HOME% 代表引用 JAVA_HOME 环境变量的值，这样以后改动时，只需要改 JAVA_HOME 这一处就可以了\n\n# 三. 入门案例\n\n这节课我们来学习 Java 的第一个入门程序，Hello world，目标是**命令** jvm，在程序窗口输出一行问候语。\n\n## 1. 第一行代码\n\n### 1) jshell\n\n首先用到的是一个名为 jshell 的开发工具，打开命令提示符 cmd，输入 jshell\n    PS D:\\> jshell\n    |  欢迎使用 JShell -- 版本 17.0.2\n    |  要大致了解该版本, 请键入: /help intro\n    jshell>\n\n可以看到【jshell>】后的光标在不断闪烁，表示可以继续在【jshell>】后键入命令或代码\n\n常见命令\n\n* /help 帮助信息\n* /exit 退出 jshell\n\n第一行代码来了：输入 `System.out.println(\"Hello, world\")`，要注意大小写和引号，查看效果\n\n### 2) 代码解读\n\n下面来解释这行代码的意思\n\n* 它的整体效果是命令 JVM，给我在在程序窗口输出一行话，话的内容是：`Hello, world`\n\n再来把代码拆解，看看每一部分的意思\n\n* 先要说明的是，咱们这个程序窗口内有两个较为抽象的组成部分，输出和输入\n  \n  * 其中输出的专业叫法是【标准输出】，用来将运算结果展现给用户，代码里就对应着 System.out\n  \n  * 另一个是【标准输入】，用来接受用户输入的数据，代码里用 System.in 表示，后面再讲\n  \n  * System.out 、System.in 代表的这种计算机中的虚拟物体，以后统称之为【对象】\n  \n  * System.out 这个对象是 java 为我们提前准备好的\n  \n  * 以后还有一些对象是需要我们自己创建的，后面会逐渐讲到\n\n但是光是拿到 System.out 对象，它并不会显示 Hello, world，我们必须给它下命令，也就是调用对象的功能\n\n* println() 代表的是 System.out 中的一种功能，以后称之为【方法】\n  * 方法的特征是在使用时会带有一对 ()\n  * 不同的方法作用不同，println 方法的作用是将 () 内的内容展现到程序窗口并换行，System.out 对象还有 print 方法，区别是不换行输出内容\n  * 前面的点，表示一种从属关系\n    * 即 println() 方法从属于 System.out 对象，print 方法也从属于 System.out 对象\n    * 从属关系决定了对象能否使用此方法，像 System.in 与 println 方法之间没有这种从属关系，就意味着 System.in 对象无法使用此 println 方法\n    * 想知道对象和哪些方法之间有从属关系，后面会给大家讲解怎么查，目前了解这些足够了\n* () 里面的 `\"hello, world\"` 叫做方法参数，你可以替换它为其它问候语\n  * 不同的方法需要的参数个数及格式也有所不同，刚才我们用的这个 println 方法只接收了一个参数，以后大家可能见到不同个数和格式的参数，这些后面都会详细讲解\n\n#### 总结\n\n从这行代码中学习了什么呀，要命令计算机执行功能，可以借助【对象】、【方法】和【参数】来完成\n\n* 刚才的例子中谁是对象？\n  \n  * System.out\n\n* 它代表什么？\n  \n  * 标准输出\n\n* 谁是方法？\n  \n  * println 是方法\n\n* 它有什么作用？\n  \n  * 不同方法作用不同，println 将括号内内容，也就是参数输出到程序窗口\n  * 这其中参数比较自由，由我们提供，可以是 hello, world, 可以是你好，也可以是其它问候语\n\n* 对象和方法是 java 提供的（当然以后我们也可以自己创建对象，定义新的方法，此乃后话）\n\n至此为止，这行代码的含义讲解完毕\n\n### 3) 为何要分成对象与方法\n\n有同学问：Java的设计者搞个输出都这么麻烦，还分成对象和方法俩概念，把它们合为一个概念不是更简单吗？你看\n\n* 对象用来表示被操作的物体，是名词\n* 方法用来告知让这个物体执行什么动作，是动词\n\n这种划分更符合现实世界中对事物的认知，例如，你叫住【皮卡丘】，皮卡丘就是待操作的对象，这时候他还不知道要做什么。好，你命令他【趴下】，这个趴下就是方法，是皮卡丘要执行的动作，你再命令他【吃饭】，这个吃饭是另一个方法。可以看到，现实世界都可以这么划分，那么把计算机中的虚拟物体抽象成对象和方法，当然也是顺理成章啦，这符合人类对事物的认知。\n\n因此，不要怕麻烦，以后在 java 世界编写的代码，绝大多数都是这种对象+方法的形式，这称之为**面向对象编程**，今天我们还不会正式讲解面向对象编程，但同学们要建立起对象、方法的概念\n\n## 2. 第一份源码\n\njshell 执行过的代码，在 jshell 退出后下次再想用，就不方便调出来了，正式的代码都会保存在类文件中，类文件的后缀是 .java，也称为 java 源代码\n\n### 1) 源码结构\n\n源码结构如下，一份源码中可以包含多个类，每个类中又可以包含多个方法，方法内再包含语句代码\n    class A {\n        方法1() {\n            // 语句代码\n        }\n        方法2() {\n            // 语句代码\n        }\n        入口方法() {\n            // 语句代码\n        }\n    }\n    class B {\n\n    }\n\n这里我们关注其中一个特殊方法：入口方法。\n\n入口方法的格式是固定的：\n    public static void main(String[] args) {\n    }\n\n以后我们就称它为 main 方法\n\n* main 并不从属于任何对象（由 static 修饰）\n* main 方法内就可以书写之前学过的那行代码 System.out.println(\"Hello, world\")\n* 要注意与之前 jshell 中一点区别是，这里的每行代码以分号结束\n\n刚才给大家介绍了源代码的结构\n\n* 源代码中可以包含多个 class 类，每个类中再去套方法，方法内再去套代码，当我们把这些写好之后，能不能交给 JVM 来执行呢？\n* 还不行，因为JVM不理解源码，需要通过 javac 开发工具把源代码编译成 class 字节码文件（这种字节码JVM可以理解）字节码文件的特点是后缀以 .class 结尾\n* 最后再通过 java 工具可以将 class 字节码加载至 JVM，JVM 将字节码解释翻译为机器码，最终就可以由 CPU 执行啦。\n\n### 2) 编写 java 源代码\n\n进入 `d:` 盘\n\n* 目的是为了找到一个合适存储 java 源代码的位置，也可以是其他位置，总之方便你找到它\n    C:\\Users\\Lenovo>d:\n    D:\\>\n\n运行记事本程序，notepad 是记事本程序名称\n    D:\\>notepad\n\n会打开如下窗口\n\n\n\n输入如下代码\n    class Hello {\n        public static void main(String[] args) {\n            System.out.println(\"hello, world\");\n        }\n    }\n\n* `\"\"` 内的 hello, world 是我们自由书写，可以是英文、汉字\n* `class` 后的 Hello 称之为【类名】，一般是英文单词\n* 其余代码要与例子中的【完全一致】，并严格区分大小写\n\n保存文件，选择 `文件->保存` 或按它对应的快捷键 `Ctrl+S`\n\n\n\n* 类名与最后的文件名请保持一致，保存为文件名以 `.java` 结尾\n* 保存文件时，确保也存储于 `d:` 盘，方便待会找到它\n* 编码位置也要注意，可能会影响到汉字的输出，后面会讲\n\n### 3) 编译 java 源代码\n\n关闭记事本程序，回到命令提示符程序，输入下面命令\n    D:\\>javac Hello.java\n\n* `javac` 用来把一个 `*.java` 文件编译成 `*.class` 文件\n\n* `*.class` 就是前面提到的 class 字节码\n\n本例中，生成的字节码文件为 `Hello.class`，可以用 `dir` 命令查阅如下\n\n\n\n### 4) 运行 class 字节码\n\n输入下面命令\n    D:\\>java Hello\n    hello, world\n\n* `java` 命令用来把 Hello.class 加载到 JVM 并执行它\n\n## 3. 常见问题\n\n### 中文输出乱码\n\n有的同学编写代码时用了中文\n    class Hello {\n        public static void main(String[] args) {\n            System.out.println(\"你好\");\n        }\n    }\n\n编译、执行后输出为\n    浣犲ソ\n\n> 发音：huan chai so\n\n原因在于，保存 Hello.java 文件时，选择了 UTF-8 编码，而 javac 编译时采用的是操作系统默认编码 GBK，只要两边编码不一致，就会发生上述的【乱码】问题\n\n#### 解决方法1\n\n保存文件时，选择编码为 ANSI（对于记事本程序 ANSI 其实就是 GBK）\n\n\n\n#### 解决方法2\n\n文件保存时，编码仍然是 UTF-8 不变，编译时改用下面的命令明确告诉编译器，编译时别用默认的 GBK，改用 UTF-8\n    D:\\>javac -encoding utf-8 Hello.java\n\n### 编译错误\n\n有的同学在执行 javac 时会遇到各种各样的问题，例如\n    D:\\>javac -encoding utf-8 Hello.java\n    Hello.java:3: 错误: 非法字符: '\\uff1b'\n            System.out.println(\"你好\")；\n                                             ^\n    1 个错误\n\n遇到这种错误不用怕\n\n* 其中 `Hello.java:3` 意思是说，Hello.java 中第 3 行出现错误，这样就可以定位错误位置\n* 接下来它又提示了具体错误原因：`错误: 非法字符: '\\uff1b'`，本例中是因为输入了中文分号 `；`，java 语法要求语句结束符号是英文分号 `;`\n* 这些错误原因需要慢慢积累，见的多了就知道该怎么解决了\n\n## 4. 注释\n\n注释就是对程序代码的一个说明，比如：\n\n* 将来写的代码多了，你记性又没那么好，怕忘记某些代码的含义，这时候可以给它加一个注释\n* 或是某些代码比较重要、特殊，这时也可以加一个注释进行说明\n\n强调一点，注释只是对代码的说明，只影响代码阅读，不影响代码的功能。\n\n注释的格式分成了单行注释，多行注释，还有文档注释三种。\n\n### 单行注释\n\n写在被注释代码的上方或右方，格式为\n    // 注释内容\n\n### 多行注释\n\n如果注释内容比较长，都写在一行影响阅读，这时候就用多行注释，格式为\n    /*\n        注释内容\n        注释内容\n    */\n\n### 文档注释\n\n文档注释我们后面讲方法时再详细来讲吧，那现在呢，你只要了解它的格式：格式为：\n    /**\n        注释内容\n    */\n\n## 5. 思考-为何需要字节码\n\n咱们先回忆一下 Java 程序的开发以及运行的流程\n\n* 首先得编写一个Java的源文件，源文件编写好了就能交给CPU来执行吗？\n* 还不行啊，他得经过一个编译的步骤，也就是用那个javac程序把它编译成字节码文件\n* 这个字节码文件呢，再经过一个叫 java 程序加载到 jvm 虚拟机，\n* jvm 虚拟机其实还做了一件很重要的事，就是把字节码文件给解释成机器码\n* 机器码就是最为底层的代码了，CPU就可以识别和运行它\n\n所以整个流程是先把源文件变成字节码，再把字节码变成机器码，最终由CPU执行。\n\n那这里大家可以思考这么一个问题，源代码，最终要变成机器码，是不是才能被CPU执行，那为什么我们不直接把Java 源码翻译成机器代码，而是多出了字节码这么一个中间环节呢？\n\n### C++ 的翻译过程\n\n要解释清楚这个问题啊，我们就必须介绍一点历史。在Java语言发明之前呢，有一个比较流行的编程语言叫做c++语言，这个c++语言它就没有中间的环节，可以把源文件直接他翻译成最终的机器码。有同学说这不挺好？但是呢有这么一个问题：不同平台下的这个机器码是不通用的。\n\n举个例子，在windows平台下编写好了c++源代码，可以把它经编译器编译为windows平台的机器码，但是这个机器码呢，只能用在windows平台。想拿到Linux平台下用，用不了。必须在 Linux 平台下，重新编译成Linux机器码。看看这样的缺点\n\n1. 项目规模大了，源码编译也挺耗时间，在 windows 下编译一遍比如用了 20 分钟，测试通过了，将来要部署到 Linux 平台，又得编译一遍，再花 20 分钟... 时间都花在编译上了\n2. 程序员还得熟悉两个平台，做不到开发与部署环境相分离\n\n说完了这是c++程序需要多次编译缺点，那咱们再来看看 Java 是怎么解决这个问题的。\n\n\n\n### Java 的翻译过程\n\nJava做的就是加入了字节码这个中间环节，不管是在Linux下的编译还是在windows下的编译，生成的字节码是所有平台都通用的，你在windows平台生成的字节码在Linux平台一样用，反之亦然。可以看到\n\n1. 编译只需要一次，编译时间被节省了\n2. 程序员只需要工作在自己熟悉的平台上就可以了，做到了开发与部署环境的分离\n\n这就是 java 所宣称的 write once run anywhere，编写一次，到处运行。\n\n字节码虽然带来了这样一些便利，但大家思考一下，有什么问题吗？\n\n对啦，问题就是字节码不是最终的机器码\n\n* 需要在每个平台上安装 jvm 虚拟机，负责把字节码解释为机器码\n* 另外因为引入了把字节码解释为机器码的步骤，性能上会有一定损失，当然 jvm 为了保证性能，内部会做很多优化，这等我们讲到 jvm 时，会有更深入的认识\n\n\n\n### 小结\n\n通过初步对比 c++ 和 java 的不同编译策略，我们学习到一个词 trade-off，权衡。\n\n* c++ 直接编译生成机器码，性能无与伦比，但一旦改变平台，会带来额外的编译成本\n* java 编译生成字节码，减少编译成本，增强灵活性，但性能不可避免受到影响，需要再通过其它方面补救\n\n以后大家如果进入到程序设计的领域，就会明白，所谓设计更多的是在各个方面做出权衡，没有最佳，只有最适合。\n\n# 四. IDE 工具\n\n俗话说，工欲善其事，必先利其器，要准备好开发工具，才能提高开发效率。如果像开始那样，用记事本编写 java 代码，不仅慢，而且很容易出错。\n\n首先来介绍 IDE 工具，IDE 即 Integrated Development Environment 集成开发环境，能够提供给开发者更好的编码、编译、测试环境\n\n## 1. 常见 IDE 工具\n\n### Eclipse\n\n老牌的 IDE 工具 Eclipse，有需要的同学可以根据下图下载尝试（[Eclipse Downloads | The Eclipse Foundation](https://www.eclipse.org/downloads/)）\n\n\n\n它的特点是\n\n* 完全免费\n* 功能够用\n\n### Vscode\n\n以上两个工具属于**重量级**的 IDE 工具，如果想追求轻量级的工具，推荐使用 Visual Studio Code\n\n\n\n它的特点有\n\n* 完全免费\n* 更为轻量，占用磁盘空间比 eclipse 和 idea 少很多，前面两个工具属于重量级 ide 工具\n* 系出名门，微软开发\n* 插件丰富，通过插件几乎可以支持所有语言\n\n最后要介绍的一个 IDE 工具叫 Intellij IDEA，号称是最智能的 java 开发工具\n\n### IntelliJ IDEA\n\n新流行的 IDE 工具 IntelliJ IDEA，推荐大家用它（[下载 IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE](https://www.jetbrains.com/zh-cn/idea/download/#section=windows)）\n\n\n\n它有三个版本\n\n* Ultimate（最终版），功能最强，按年收费，价格不菲\n* Community（社区版），功能够用\n* 如果你是在校学生，可以申请教育版\n  * [通过教育邮箱免费申请IntelliJ IDE全家桶教程 - 简书 (jianshu.com)](https://www.jianshu.com/p/fc56eadc7faf)\n\n特点\n\n* 更加智能\n\n因为我不想花钱，下载的是社区版，另外我选择的这种zip压缩格式的安装包，它使用起来更加简单，解压就能用\n\n使用步骤\n\n* 选中下载好的压缩文件，解压，这里解压到 d：盘，注意保留后面的文件夹名称\n\n* 进入d盘，进入解压目录中 bin子目录，找到一个名叫 idea64的程序双击，就可以运行了。\n\n## 2. IntelliJ IDEA 的配置及使用\n\n本教程使用 IntelliJ IDEA Community 2022.1（截至本教程开始开发时的最新版本）\n\n### 1) 安装启动\n\n首次运行，会弹出下面窗口\n\n\n\n意思是是否导入以前的设置（settings），因为我们是第一次安装，所以就选择默认的不导入设置\n\n出现 splash 欢迎页\n\n\n\n接下来进入主界面\n\n\n\n在学习 idea 之前，先来做几项简单的设置，可以改改颜色主题（`Customize -> Color theme`）\n\n\n\n如果选择 `Sync with OS`，意思就是根据操作系统改变主题（白天亮、夜晚暗）\n\n\n\n推荐安装翻译插件，方便阅读文档\n\n\n\n### 2) 创建项目\n\n创建新项目（Project）\n\n\n\n在 IDEA 中【项目】和【模块】用来组织代码\n\n* 一个【项目】（Project）包含多个【模块】（Module）\n* 一个【模块】（Module）包含多个【源文件】\n\n点击【新建项目】（New Project）后出现界面\n\n\n\n其中\n\n* 存储位置中的 `~` 代表当前用户目录\n  * 如我的 Windows 系统用户名为 `Lenovo`，则 `~` 对应目录为 `C:\\Users\\Lenovo`\n  * 你也可以选择其它目录来存储【项目】位置，但注意目录中不建议有中文和空格\n* 语言这目前选择 `Java`，但要知道 JVM 还能运行其它几种语言：`Kotlin` 和 `Groovy`\n* 项目类型目前选择 `IntelliJ`，后续我们还会学习 `Maven` 和 `Gradle`\n* 如果安装了 JDK，会出现在这个下拉列表中\n* 如果勾选了 `Add sample code`，则会生成一个简单的实例代码\n\n点击 `Create` 按钮后\n\n\n\n首次进入项目会在右下角显示两个弹窗通知\n\n\n\n建议都点一下\n\n* 前者能将 IntelliJ IDEA 的菜单中文化\n* 后者能加速 IDEA 的使用速度\n\n因为前面勾选了实例代码，因此 idea 已经帮我们生成了一个简单的源文件，看一下，里面已经包含了类、main 方法和一段 hello world 代码。\n\n### 3) 运行代码\n\n\n\n# 五. 实用工具\n\n## 1. Ubuntu 子系统\n\n如果用 Windows 操作系统，推荐安装 Linux 子系统，即 WSL\n\n* 适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销\n* 官方安装文档：[安装 WSL | Microsoft Docs](https://docs.microsoft.com/zh-cn/windows/wsl/install)\n\n### 1) 安装 wsl 工具\n\n    wsl --install\n\n### 2) 安装 Ubuntu 子系统\n\nUbuntu 是一种非常流行的 Linux 系统，打开微软应用商店\n\n\n\n搜索 ubuntu\n\n\n\n选一个版本安装（我用的是 18.04 LTS）\n\n### 3) 运行 Ubuntu 子系统\n\n安装完毕后，打开命令提示符，输入 wsl，即可进入 Ubuntu 子系统\n\n\n\n这里就可以运行各种 Linux 下的 App 了，当然我们主要用的是命令行下的 App，图形界面的 App 不行\n\n## 2. 终端工具\n\n命令提示符这个工具虽然能用，但是界面比较 low，这里给大家介绍一款终端工具：Fluent Terminal，也是在微软应用商店搜索\n\n\n\n运行界面如下\n\n\n\n好处是同时支持三种终端\n\n* CMD（命令提示符）\n* PowerShell（Windows 下另一个终端工具）\n* WSL\n\n## 3. 截图工具\n\n做笔记的神器：Snipaste，也是在微软应用商店搜索\n\n\n\n## 4. 笔记工具\n\n笔记神器：Typora，1.0 版本后收费 89 元（可以找找低版本的），当然你也可以选择其它笔记工具\n\n\n\n## 5. 思维导图工具\n\n推荐使用 Xmind 工具，免费的功能就够用\n","tags":["Java"],"categories":["编程"]},{"title":"麻辣鱼","url":"/2024/04/09/麻辣鱼/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]